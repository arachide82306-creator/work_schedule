<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8"/>
<title>勤務予定表入力アプリ</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="data:," rel="icon"/><!-- favicon 404回避 -->
<style>
    :root{
      --bg-body:#f4f5f7;--bg-header:#fff;--bg-sidebar:#fff;--bg-main:#fff;
      --border-soft:#e0e3e7;--border-strong:#c1c7d0;
      --text-main:#1f2933;--text-muted:#6b7280;
      --accent:#1976d2;--accent-soft:#e3f2fd;--accent-strong:#0d47a1;
      --danger:#d32f2f;--danger-soft:#fdecea;
      --success:#2e7d32;--success-soft:#e8f5e9;
      --warning:#f9a825;
      --shadow-soft:0 1px 3px rgba(15,23,42,.12);
      --radius:6px;--transition-fast:.15s ease;
      --sidebar-width:280px;--header-height:64px;
      --font-jp:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Yu Gothic UI","Meiryo",sans-serif;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;height:100%;font-family:var(--font-jp);color:var(--text-main);background:var(--bg-body)}
    body{display:flex;flex-direction:column}
    header{height:var(--header-height);background:var(--bg-header);box-shadow:var(--shadow-soft);
      display:flex;align-items:center;justify-content:space-between;padding:8px 16px;gap:16px;position:sticky;top:0;z-index:10}
    .header-left,.header-right{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .app-title{font-weight:650;letter-spacing:.08em;font-size:14px;color:var(--text-muted);margin-right:6px}
    .field-group{display:flex;flex-direction:column;gap:2px;font-size:11px;color:var(--text-muted)}
    select,input[type="month"]{padding:5px 10px;border-radius:8px;border:1px solid var(--border-soft);background:#fff;font-size:13px;min-width:160px;outline:none;
      transition:border-color var(--transition-fast),box-shadow var(--transition-fast)}
    select:focus,input[type="month"]:focus{border-color:var(--accent);box-shadow:0 0 0 2px rgba(25,118,210,.15)}
    .toggle{display:inline-flex;align-items:center;gap:8px;font-size:12px;cursor:pointer;padding:6px 10px;border-radius:999px;border:1px solid var(--border-soft);background:#fff;
      transition:box-shadow var(--transition-fast),border-color var(--transition-fast);user-select:none}
    .toggle input{display:none}
    .toggle-pill{width:34px;height:18px;border-radius:999px;background:#e5e7eb;position:relative;transition:background-color var(--transition-fast)}
    .toggle-thumb{width:16px;height:16px;border-radius:50%;background:#fff;position:absolute;top:1px;left:1px;box-shadow:0 1px 3px rgba(0,0,0,.15);transition:transform var(--transition-fast)}
    .toggle.on .toggle-pill{background:var(--success)} .toggle.on .toggle-thumb{transform:translateX(16px)}
    .toggle.on{border-color:rgba(46,125,50,.35);box-shadow:0 0 0 2px rgba(46,125,50,.12)}
    button{border:1px solid var(--border-soft);border-radius:999px;padding:7px 14px;font-size:13px;cursor:pointer;background:#fff;color:var(--text-main);
      display:inline-flex;align-items:center;gap:6px;transition:background-color var(--transition-fast),box-shadow var(--transition-fast),border-color var(--transition-fast),transform var(--transition-fast);user-select:none}
    button.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
    button.primary:hover:not(:disabled){background:var(--accent-strong);border-color:var(--accent-strong)}
    button.icon{padding:7px 10px;border-radius:12px}
    button:hover:not(:disabled){background:#f3f4f6;box-shadow:0 2px 8px rgba(15,23,42,.12);transform:translateY(-.5px)}
    button:active:not(:disabled){transform:translateY(0);box-shadow:none}
    button:disabled{opacity:.55;cursor:default;box-shadow:none}
    .app-main{flex:1;display:flex;min-height:0;overflow:hidden}
    aside.sidebar{width:var(--sidebar-width);min-width:var(--sidebar-width);background:var(--bg-sidebar);box-shadow:1px 0 0 var(--border-soft);
      padding:12px 12px 16px;display:flex;flex-direction:column;gap:12px}
    .sidebar-section{border-radius:var(--radius);border:1px solid var(--border-soft);padding:10px;background:#fff}
    .sidebar-section h3{margin:0 0 8px;font-size:12px;font-weight:700;color:var(--text-muted);letter-spacing:.08em;text-transform:uppercase}
    .sidebar-row{display:flex;justify-content:space-between;align-items:center;gap:10px;font-size:12px}
    .badge{display:inline-flex;align-items:center;padding:3px 10px;border-radius:999px;font-size:11px;border:1px solid transparent;gap:6px;font-weight:650}
    .badge.work{background:var(--accent-soft);color:var(--accent-strong);border-color:rgba(25,118,210,.2)}
    .badge.leave{background:var(--success-soft);color:var(--success);border-color:rgba(46,125,50,.2)}
    .badge.support{background:#eef2ff;color:#3730a3;border-color:rgba(55,48,163,.2)}
    .keypad{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:6px;margin-top:6px}
    .keypad button{padding:8px 10px;border-radius:10px;justify-content:space-between;font-size:12px}
    .keypad .code-label{font-weight:800;min-width:1.6em}
    .sidebar-section small{font-size:11px;color:var(--text-muted);display:block;margin-top:6px;line-height:1.35}
    .alert-list{max-height:200px;overflow:auto;margin-top:8px}
    .alert-item{font-size:11px;padding:6px 8px;border-radius:10px;background:var(--danger-soft);color:var(--danger);margin-bottom:6px;border:1px solid rgba(211,47,47,.15);line-height:1.35}
    .alert-item.good{background:var(--success-soft);color:var(--success);border-color:rgba(46,125,50,.15)}
    .ime-alert{font-size:11px;color:#7c5b00;background:#fff8e1;border-radius:10px;padding:8px 10px;margin-top:8px;border:1px solid rgba(249,168,37,.25);display:none;line-height:1.35}
    .ime-alert.visible{display:block}
    main{flex:1;padding:12px 12px 16px;min-width:0;display:flex;flex-direction:column;gap:10px}
    .schedule-header{display:flex;justify-content:center;align-items:center;padding:4px 0 2px;min-height:34px}
    .schedule-title{font-weight:750;font-size:15px;letter-spacing:.06em}
    .schedule-wrapper{flex:1;border-radius:var(--radius);border:1px solid var(--border-soft);background:var(--bg-main);display:flex;flex-direction:column;min-height:0;
      box-shadow:0 1px 0 rgba(15,23,42,.02)}
    .schedule-inner{flex:1;overflow:auto;position:relative;overscroll-behavior:contain}
    table.schedule{border-collapse:collapse;width:max-content;min-width:100%;font-size:12px}
    table.schedule th,table.schedule td{border:1px solid var(--border-soft);padding:3px 4px;text-align:center;white-space:nowrap;min-width:34px;max-width:44px;height:24px}

table.schedule thead th{position:sticky;top:0;z-index:10;background:#fafafa;font-weight:600}
        .weekday-row th{font-size:11px;color:var(--text-muted);font-weight:650}
    .day-sat{color:#1976d2}.day-sun{color:#d32f2f}
    .cell-emp-name{font-weight:650;text-align:center;vertical-align:middle;padding:4px 6px}
    .employee-main-row td{border-bottom:1px dashed var(--border-strong)!important}
    .employee-main-row td,.employee-note-row td{border-top:1px dashed var(--border-strong)!important}
    .employee-note-row td{border-top:1px dashed var(--border-strong)!important}
    .support-row td{background:#f9fafb;font-size:11px}
    .support-first th,.support-first td{border-top:3px double var(--border-strong)!important}
    .cell-support-header{font-weight:650}
    .cell-selected{box-shadow:inset 0 0 0 2px #1976D2;}
    .cell-multi{box-shadow:inset 0 0 0 2px #1976D2;}


    /* ドラッグ範囲選択中はテキスト選択を抑止して視認性を上げる */
    .drag-selecting, .drag-selecting *{
      -webkit-user-select:none!important;
      user-select:none!important;
    }
    .cell-error{box-shadow:inset 0 0 0 2px var(--danger);background:#fff0f0!important}
    .cell-readonly{background:#f3f4f6!important;color:var(--text-muted)!important;cursor:default!important}
    .cell-bg-colored{color:#111827;font-weight:800}
    .cell-work-text{font-weight:800}
    .notice{font-size:12px;color:var(--text-muted);padding:10px 12px}

    .modal-backdrop{position:fixed;inset:0;background:rgba(15,23,42,.34);display:none;align-items:center;justify-content:center;z-index:100;padding:16px}
    .modal-backdrop.visible{display:flex}
    .modal{background:#fff;border-radius:16px;box-shadow:0 18px 40px rgba(15,23,42,.28);max-width:980px;width:100%;max-height:92vh;display:flex;flex-direction:column;overflow:hidden}
    .modal-header{padding:12px 16px;border-bottom:1px solid var(--border-soft);display:flex;justify-content:space-between;align-items:center;gap:10px;background:#fff}
    .modal-header h2{margin:0;font-size:15px;font-weight:800;letter-spacing:.04em}
    .modal-body{padding:12px 16px 14px;overflow:auto;font-size:13px}
    .modal-footer{padding:10px 16px;border-top:1px solid var(--border-soft);display:flex;justify-content:flex-end;gap:8px;align-items:center;background:#fff}
    .modal-tabs{display:flex;border-bottom:1px solid var(--border-soft);margin-bottom:10px;gap:6px}
    .modal-tab{padding:8px 12px;font-size:13px;cursor:pointer;border-radius:12px 12px 0 0;border-bottom:2px solid transparent;color:var(--text-muted);
      transition:color var(--transition-fast),border-color var(--transition-fast),background-color var(--transition-fast);user-select:none}
    .modal-tab.active{border-bottom-color:var(--accent);color:var(--accent-strong);background:#f3f8ff}
    .settings-panel{display:none}.settings-panel.active{display:block}
    .settings-table{width:100%;border-collapse:collapse;margin-bottom:10px;border-radius:12px;overflow:hidden}
.employee-table-fixed{table-layout:fixed}
.employee-table-fixed th,.employee-table-fixed td{border:1px solid var(--border-soft);padding:6px 8px;font-size:12px;vertical-align:middle}
.employee-table-fixed th{background:#f9fafb;font-weight:800}
.employee-drag-handle{cursor:grab;user-select:none;text-align:center;color:#6b7280;font-weight:900}
.employee-drag-handle:active{cursor:grabbing}
.employee-table-fixed input,.employee-table-fixed select{width:100%;box-sizing:border-box}

    .settings-table th,.settings-table td{border:1px solid var(--border-soft);padding:6px 8px;font-size:12px;text-align:left;vertical-align:top}
    .settings-table th{background:#f9fafb;font-weight:800}
    .settings-table input[type="text"],.settings-table input[type="number"],.settings-table select{width:100%;font-size:12px;padding:6px 8px;border-radius:10px;border:1px solid var(--border-soft);outline:none}
    .settings-table input[type="text"]:focus,.settings-table input[type="number"]:focus,.settings-table select:focus{border-color:var(--accent);box-shadow:0 0 0 2px rgba(25,118,210,.12)}
    .settings-table input[type="color"]{padding:0;border:none;background:transparent;width:38px;height:28px}
    .settings-inline-controls{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
    .pill{padding:6px 10px;border-radius:999px;font-size:11px;border:1px solid var(--border-soft);background:#f9fafb;display:inline-flex;align-items:center;gap:6px}
/* v193: 店舗タブ 業務コードの状態を「ドット＋テキスト」で視認性UP（ごちゃごちゃさせない） */
#settingsStores .status-dot{
  width:8px;
  height:8px;
  border-radius:50%;
  display:inline-block;
  flex:0 0 auto;
}
#settingsStores .status-dot.dot-day{ background:#f59e0b; }      /* 日勤 */
#settingsStores .status-dot.dot-night{ background:#7c3aed; }    /* 夜勤（青系） */
#settingsStores .status-dot.dot-disabled{ background:#9ca3af; } /* 無効 */

    .pill select{min-width:72px;padding:4px 8px;border-radius:999px}
    .text-danger{color:var(--danger)}.text-muted{color:var(--text-muted)}
    .divider{height:1px;background:var(--border-soft);margin:8px 0}
    .unsaved-body{font-size:13px;padding:12px 16px 4px}
    .unsaved-body p{margin:0 0 8px}
    .unsaved-body ul{padding-left:18px;margin:6px 0 0}
    .unsaved-body li{margin:4px 0}
    @media(max-width:980px){header{flex-direction:column;align-items:flex-start;height:auto}.header-left,.header-right{width:100%;justify-content:space-between}aside.sidebar{display:flex}}
    @media print{
      @page{size:A4 landscape;margin:8mm}
      header,aside.sidebar{display:none!important}
      body{background:#fff!important}
      main{padding:0!important}
      .schedule-wrapper{border:none!important}
      .schedule-inner{flex:1;overflow:auto;position:relative;overscroll-behavior:contain}
      table.schedule thead th{position:sticky;top:0;z-index:10;background:#fafafa;font-weight:600}
      .cell-emp-name,.col-employee-header,.cell-support-header{position:static!important}
    }
  
    .cell-preview-add{
    outline: 2px dashed #1976D2 !important;
    outline-offset: -2px !important;
    box-shadow: none !important;
  }
    .cell-preview-remove{
    outline: 2px dashed rgba(120, 120, 120, .55) !important;
    outline-offset: -2px !important;
    box-shadow: none !important;
  }
  .drag-hint{
    margin-top:10px;
    padding:8px 10px;
    border-radius:10px;
    background: rgba(33,115,255,.06);
    border: 1px solid rgba(33,115,255,.18);
    color: var(--text);
    font-size:12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
  }
  .drag-hint.hidden{ display:none; }
  .drag-hint .pill{
    font-weight:800;
    padding:4px 8px;
    border-radius:999px;
    background: rgba(0,0,0,.04);
    border:1px solid rgba(0,0,0,.06);
    color: var(--text);
    white-space:nowrap;
  }
  .drag-hint.add{ background: rgba(33,115,255,.06); border-color: rgba(33,115,255,.18); }
  .drag-hint.add .pill{ border-color: rgba(33,115,255,.22); }
  .drag-hint.remove{ background: rgba(0,0,0,.04); border-color: rgba(0,0,0,.12); }
  .drag-hint.remove .pill{ border-color: rgba(0,0,0,.18); }


  #scheduleTable td:focus{ outline:none; }
  #scheduleTable td:focus-visible{ outline:none; }

    /* schedule cell focus ring: suppress UA focus outline (prevents black flicker during drag) */
  #scheduleTable td:focus{ outline:none !important; }
  #scheduleTable td:focus-visible{ outline:none !important; }


  #scheduleTable td.cell-preview-add.cell-selected,
  #scheduleTable td.cell-preview-add.cell-multi,
  #scheduleTable td.cell-preview-remove.cell-selected,
  #scheduleTable td.cell-preview-remove.cell-multi{
    box-shadow: none !important;
  }


  /* focused cell can be the drag start; keep preview dashed outline visible even on :focus */
  #scheduleTable td.cell-preview-add:focus,
  #scheduleTable td.cell-preview-add:focus-visible{
    outline: 2px dashed #1976D2 !important;
    outline-offset: -2px !important;
  }
  #scheduleTable td.cell-preview-remove:focus,
  #scheduleTable td.cell-preview-remove:focus-visible{
    outline: 2px dashed rgba(120, 120, 120, .55) !important;
    outline-offset: -2px !important;
  }



.cell-emp-name, .cell-support-header{
  background:#fff; /* 透け防止 */
  box-shadow:none;
}







table.schedule thead tr:nth-child(1) th{
  top:0;
  z-index:10;
}
table.schedule thead tr:nth-child(2) th{
  top:24px; /* 1段目(数字)の高さ */
  z-index:20;
}
/* 左上の「従業員」(rowspan=2) は top+left 両方 sticky で最前面 */
table.schedule thead th.namecol{
  position:sticky;
  top:0;
  left:0;
  z-index:9999;
  background:#fafafa;
}
/* 行見出し（従業員名 / 応援行見出し）は left 固定。列見出しより背面 */
table.schedule tbody th.cell-emp-name,
table.schedule tbody th.cell-support-header{
  position:sticky;
  left:0;
  z-index:5;
  background:#fff;
}



/* ===== Sticky見出し（2段thead + 左固定列）: overlap防止 & 左上常時表示 ===== */
/* 2段thead: 1段目(日付)と2段目(曜日)で top を分ける */
#scheduleTable thead tr:nth-child(1) th{ top:0; z-index:30; }
#scheduleTable thead tr:nth-child(2) th{ top:24px; z-index:40; } /* 1段目の高さ(24px) */

/* 左上「従業員」: 横スクロールでも絶対に隠れない */
#scheduleTable thead th.namecol{
  position: sticky !important;
  top: 0 !important;
  left: 0 !important;
  z-index: 9999 !important;
  background: #fafafa !important;
  /* 二重罫線を防ぐため、境界側の線は相手(右/下)に任せる */
  border-right: 0 !important;
  border-bottom: 0 !important;
}

/* 行見出し（従業員名 / 応援行見出し）を left 固定 */
#scheduleTable tbody th.cell-emp-name,
#scheduleTable tbody th.cell-support-header{
  position: sticky !important;
  left: 0 !important;
  z-index: 50 !important; /* 本文セルより前面、列見出しより背面 */
  background: #fff !important;
  border-right: 0 !important; /* 境界の太線化を防ぐ */
}

/* 左列の補助ヘッダー背景 */
#scheduleTable tbody th.cell-support-header{ background:#f9fafb !important; }

/* thead th の基底は schedule の既存を使うが、namecol は left 固定のため別扱い */
#scheduleTable thead th{ position: sticky; }

/* 「従業員」セルの下(=tbodyの最初の行)との境界線は tbody 側に任せる */
#scheduleTable tbody tr:first-child th,
#scheduleTable tbody tr:first-child td{ border-top:1px solid var(--border-soft); }





/* ===== 行見出し（従業員列）とコード欄の境界線を 1px で統一 =====
   二重線化を防ぐため、境界は「行見出し列の右border」を採用し、
   1日列（最初のコード列）の左borderは消す。
*/
#scheduleTable thead th.namecol,
#scheduleTable tbody th.cell-emp-name,
#scheduleTable tbody th.cell-support-header{
  border-right:1px solid var(--border-soft) !important;
}
#scheduleTable thead th.namecol{
  border-bottom:1px solid var(--border-soft) !important;
}
#scheduleTable thead th[data-day="1"],
#scheduleTable tbody td[data-day="1"]{
  border-left:0 !important;
}



/* ===== 列見出し2段（日付/曜日）間の“透け”防止：罫線は必ず見えるようにする =====
   sticky + border-collapse の組み合わせで、行間の罫線が欠けて背後の値が見えることがあるため、
   罫線は曜日行(2段目)の上に 1px のinset影で描画し、日付行(1段目)の下罫線は無効化する。
*/
#scheduleTable thead th{
  background:#fff !important;
  background-clip: padding-box;
}
#scheduleTable thead tr:nth-child(1) th{
  border-bottom:0 !important;
}
#scheduleTable thead tr:nth-child(2) th{
  border-top:0 !important;
  box-shadow: inset 0 1px 0 var(--border-soft);
}



/* ===== スクロール時の“周囲チラつき(セル値の透け)”防止 =====
   overflow+sticky の合成で、スクロール中に文字がコンテナ外へ一瞬描画されることがあるため、
   1) 外枠でクリップ(overflow:hidden) 2) スクロール領域を不透明背景 3) paint containment を付与。
*/
.schedule-wrapper{
  overflow:hidden; /* 角丸・外枠の外へはみ出す描画をクリップ */
}
.schedule-inner{
  background:#fff; /* スクロール領域の背後を不透明にして“透け”を防止 */
  contain: paint;  /* 描画をこの領域に閉じ込める（ちらつき軽減） */
  isolation: isolate;
  -webkit-overflow-scrolling: auto;
}
table.schedule{
  background:#fff;
}


    /* v91: 従業員タブ 2カラム（全体一覧 + 店舗別順序） */
    .employee-two-col{display:flex;gap:12px;align-items:flex-start}
    .employee-col{background:rgba(255,255,255,.7);border:1px solid var(--line);border-radius:14px;padding:10px}
    .employee-col-left{flex:1 1 62%;min-width:420px}
    .employee-col-right{flex:1 1 38%;min-width:280px}
    .employee-order-head{display:flex;flex-direction:column;gap:6px;margin-bottom:8px}
    .employee-order-row{display:flex;gap:10px;align-items:center}
    .employee-order-row .label{font-size:12px;font-weight:800;color:#374151;min-width:40px}
    .employee-order-row select{width:100%}
    .employee-order-list{border:1px dashed rgba(0,0,0,.12);border-radius:12px;padding:8px;min-height:120px;background:rgba(255,255,255,.55)}
    .employee-order-item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;border-radius:10px;border:1px solid rgba(0,0,0,.08);background:rgba(255,255,255,.9);margin-bottom:8px}
    .employee-order-item:last-child{margin-bottom:0}
    .employee-order-item .name{font-weight:800}
    .employee-order-item .meta{font-size:11px;color:#6b7280}
    .employee-order-handle{font-size:14px;opacity:.6;user-select:none}
    @media (max-width: 980px){
      .employee-two-col{flex-direction:column}
      .employee-col-left,.employee-col-right{min-width:0;width:100%}
    }

  
/* v107 layout fix */
.employee-settings-container{
  display: grid;
  grid-template-columns: minmax(420px, 520px) 1fr;
  gap: 16px;
  align-items: stretch;
}
.employee-left{
  max-width: 520px;
  overflow-x: auto;
}
.employee-right{
  min-width: 0;
}


/* v108: ensure left/right never overlap */
.employee-settings.employee-settings-container{
  display:flex !important;
  flex-direction:row !important;
  gap:16px !important;
  align-items:stretch !important;
  width:100% !important;
  max-width:100% !important;
  box-sizing:border-box !important;
}
.employee-settings.employee-settings-container .employee-left-panel{
  flex:0 0 520px !important;
  max-width:520px !important;
  min-width:420px !important;
  overflow:auto !important;
  box-sizing:border-box !important;
}
.employee-settings.employee-settings-container .employee-right-panel{
  flex:1 1 auto !important;
  min-width:0 !important; /* critical for overflow in flex */
  overflow:auto !important;
  box-sizing:border-box !important;
}
/* If viewport is narrow, stack panels vertically instead of overlapping */
@media (max-width: 980px){
  .employee-settings.employee-settings-container{
    flex-direction:column !important;
  }
  .employee-settings.employee-settings-container .employee-left-panel{
    flex:0 0 auto !important;
    max-width:100% !important;
    min-width:0 !important;
  }
}


/* v109: prevent left/right overlap in Employee tab */
.employee-two-col{
  display:grid !important;
  grid-template-columns: minmax(0, 1fr) minmax(280px, 360px) !important;
  gap:16px !important;
  align-items:start !important;
  width:100% !important;
  max-width:100% !important;
  box-sizing:border-box !important;
}
.employee-col-left, .employee-col-right{
  min-width:0 !important; /* critical: allow content to shrink within grid */
  box-sizing:border-box !important;
}
.employee-col-left{
  overflow-x:auto !important; /* wide table scrolls here */
}
.employee-col-left table{
  min-width:680px; /* keeps header/body aligned; scroll instead of pushing right */
}
@media (max-width: 980px){
  .employee-two-col{
    grid-template-columns: 1fr !important;
  }
  .employee-col-left table{
    min-width:0;
    width:100%;
  }
}


/* v110: autofit left employee table (avoid inner horizontal scroll) */
.employee-col-left{
  overflow-x:hidden !important;
}
.employee-col-left table{
  width:100% !important;
  min-width:0 !important;
  table-layout:fixed !important;
}
.employee-col-left th, .employee-col-left td{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.employee-col-left input,
.employee-col-left select,
.employee-col-left button{
  width:100% !important;
  min-width:0 !important;
  max-width:100% !important;
  box-sizing:border-box !important;
}
.employee-col-left .drag-handle{
  width:100%;
  text-align:center;
  cursor:grab;
}
.employee-col-left .drag-handle:active{ cursor:grabbing; }
/* Make delete button compact if it's text */
.employee-col-left .btn-delete,
.employee-col-left button[data-action="delete-employee"]{
  width:auto !important;
  padding-left:10px !important;
  padding-right:10px !important;
  white-space:nowrap !important;
}


/* v112: cursor only on row drag handles (not header) */
th.employee-drag-handle{ cursor:default !important; }
td .emp-drag-handle{
  /* v160: match row control height and keep icon centered */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: 32px;  /* matches input/select/button height (v158) */
  line-height: 1;
  cursor: grab;
}
td .emp-drag-handle:active{ cursor:grabbing !important; }
/* make sure the whole handle cell doesn't imply draggable on header */
td.emp-drag-cell{ user-select:none; text-align:center; }

/* v201: employee left table rows are draggable anywhere (except controls) */
#settingsEmployees .employee-col.employee-col-left table.employee-table-fixed tbody tr{
  cursor: grab;
}
#settingsEmployees .employee-col.employee-col-left table.employee-table-fixed tbody tr:active{
  cursor: grabbing;
}
/* controls keep their own cursor */
#settingsEmployees .employee-col.employee-col-left table.employee-table-fixed tbody tr input,
#settingsEmployees .employee-col.employee-col-left table.employee-table-fixed tbody tr select,
#settingsEmployees .employee-col.employee-col-left table.employee-table-fixed tbody tr textarea{
  cursor: text;
}
#settingsEmployees .employee-col.employee-col-left table.employee-table-fixed tbody tr button{
  cursor: pointer;
}



/* v113: right panel drag handle cursor */
.employee-order-item .drag-handle{
  cursor:grab !important;
}
.employee-order-item .drag-handle:active{
  cursor:grabbing !important;
}
/* safety: if any header uses .drag-handle, don't show grab there */
th .drag-handle{ cursor:default !important; }


/* v114: expand left table draggable area to whole drag cell */
td.emp-drag-cell{
  cursor:grab !important;
}
td.emp-drag-cell:active{
  cursor:grabbing !important;
}
th.employee-drag-handle{
  cursor:default !important;
}


/* v116: drag UX - show not-allowed outside droppable zones */
html.is-dragging, html.is-dragging *{
  cursor: not-allowed !important;
}

/* v117: move cursor ONLY when insertion placeholder is shown */
html.is-dragging .employee-order-placeholder,
html.is-dragging .employee-order-placeholder *{
  cursor: move !important;
}

/* subtle highlight for drop zones while dragging */
html.is-dragging .drop-allowed{
  outline: 1px dashed rgba(0,0,0,.22);
  outline-offset: 2px;
}
html.is-dragging .drop-allowed.drop-over{
  outline: 2px solid rgba(0,0,0,.35);
  background: rgba(0,0,0,.03);
}


/* v127: 2-step highlight for right drop area
   Step1 (dragging): show destination (outer frame only)
   Step2 (over drop area): stronger highlight to indicate you can release
   Also hide inner dashed/strong lines (placeholders/items) */
html.is-dragging .drop-allowed:not(#employeeOrderList){
  outline: none !important;
  outline-offset: 0 !important;
  background: transparent !important;
  box-shadow: none !important;
}
html.is-dragging .drop-allowed.drop-over:not(#employeeOrderList){
  outline: none !important;
  background: transparent !important;
  box-shadow: none !important;
}

/* Step1: destination hint (subtle) */
html.is-dragging #employeeOrderList{
  border-color: rgba(25,118,210,.35) !important;
  box-shadow: 0 0 0 2px rgba(25,118,210,.18);
  background: rgba(25,118,210,.04);
}

/* Step2: active target (strong) */
html.is-dragging #employeeOrderList.drop-over{
  border-color: rgba(25,118,210,.75) !important;
  box-shadow: 0 0 0 3px rgba(25,118,210,.28);
  background: rgba(25,118,210,.08);
}



/* === Settings tables: rounded frame (Stores / WorkCodes / LeaveCodes) === */
.settings-table-frame{
  position: relative;
  overflow: hidden;
  border-radius: 12px;
  background: #fff;
  isolation: isolate;
}
/* Draw outer border inside so corners never look "cut" */
.settings-table-frame::after{
  content:"";
  position:absolute;
  inset:0;
  border-radius:12px;
  box-shadow: inset 0 0 0 1px var(--border-soft);
  pointer-events:none;
  z-index: 3;
}
/* Make table flush to frame (avoid orange margin gap in DevTools) */
.settings-table-frame > table.settings-table{
  margin:0;
  width:100%;
  background: transparent;
  position: relative;
  z-index: 1;
}

/* === Add buttons as link-style with plus prefix === */
.add-link-btn{
  appearance: none;
  border: none;
  background: transparent;
  color: var(--accent, #2b6cff);
  font: inherit;
  font-weight: 600;
  padding: 6px 8px;
  border-radius: 10px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  user-select: none;
  transition: background-color .15s ease, transform .05s ease, color .15s ease, box-shadow .15s ease;
}
.add-link-btn::before{
  content: "+";
  font-weight: 800;
  line-height: 1;
}
.add-link-btn:hover{
  background: color-mix(in srgb, var(--accent, #2b6cff) 10%, transparent);
}
.add-link-btn:active{
  background: color-mix(in srgb, var(--accent, #2b6cff) 18%, transparent);
  transform: translateY(1px);
}
.add-link-btn:focus-visible{
  outline: none;
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent, #2b6cff) 25%, transparent);
}


/* === Fix: employee add button should not stretch full width === */
#settingsEmployees .employee-col-left button.add-link-btn{
  width: auto !important;
  max-width: none !important;
  justify-content: flex-start;
}


    /* v191: keep settings modal height stable; scroll inside panels */
    #settingsModalBackdrop .modal{height:92vh; max-height:92vh;}
    #settingsModalBackdrop .modal-body{
      flex:1;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      min-height:0;
    }
    #settingsModalBackdrop .modal-tabs{flex:0 0 auto;}
    #settingsModalBackdrop .settings-panels{
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
    }
    #settingsModalBackdrop .settings-panel{
      height:100%;
      overflow:auto;
      padding-right:2px;
    }
    /* reduce vertical jump from margins */
    #settingsModalBackdrop .settings-table{margin-bottom:0;}

</style>
<style id="v158-fix-employee-col-widths">
/* v157:
   1列目（ドラッグ）= 28px 固定
   2列目（姓）= 80px 固定
   3列目（名）= 80px 固定
   5列目（店舗内順）= 80px 固定
   6列目（削除）= 60px 固定
   4列目（所属店舗）= 残り幅（自動で伸縮）
   目的：横スクロールを出さず、列4だけがウィンドウ幅に合わせて伸縮する
*/
#settingsEmployees .employee-col-left{
  overflow-x:hidden !important;
}

/* 左表テーブルは親幅にフィット。列幅は colgroup で支配（inlineの%指定を上書き） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed{
  width:100% !important;
  min-width:0 !important;
  table-layout:fixed !important;
}

/* colgroup 幅（inline style を確実に上書き） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed col.drag-col{
  width:28px !important;
  min-width:28px !important;
  max-width:28px !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed col:nth-child(2){
  width:80px !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed col:nth-child(3){
  width:80px !important;
}
/* 4列目：残り幅（= 100% - (28+80+80+80+60)px = 100% - 328px） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed col:nth-child(4){
  width:calc(100% - 328px) !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed col:nth-child(5){
  width:80px !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed col:nth-child(6){
  width:60px !important;
}

/* 1列目セルは見た目も 28px に固定（padding 等で太らないように） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed thead th:first-child,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody td:first-child{
  width:28px !important;
  min-width:28px !important;
  max-width:28px !important;
  padding:0 !important;
  box-sizing:border-box !important;
  overflow:hidden !important;
}

/* 入力UIが列幅を壊さないようにフィットさせる */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed td > input,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed td > select,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed td > button{
  width:100% !important;
  max-width:100% !important;
  box-sizing:border-box !important;
}

/* v158: align delete button height with inputs/selects in employee table */
#settingsEmployees table.settings-table.employee-table-fixed input,
#settingsEmployees table.settings-table.employee-table-fixed select{
  height:32px !important;
}

#settingsEmployees table.settings-table.employee-table-fixed button{
  height:32px !important;
  padding:0 10px !important;
  line-height:1 !important;
  display:inline-flex !important;
  align-items:center !important;
  justify-content:center !important;
  box-sizing:border-box !important;
}

</style>
<style id="v170-round-employee-table-corners">
/* v170: 従業員タブ（左表）の角丸を「欠けずに」表示する
   方針：外枠はセルborderで作らず、ラッパー(div.employee-col-left)の ::after で内側に1px描画。
   これにより border-radius + border の欠け/ギザつきを回避する。
*/

/* 角丸クリップ＋重なり事故防止 */
/* frame: table only (not the add button) */
#settingsEmployees .employee-table-frame{
  position: relative !important;
  overflow: hidden !important;
  border-radius: 12px !important;
  border: 0 !important;
  background: #fff !important;
  isolation: isolate;
}

/* 外枠を内側に1pxで描く（角が欠けない） */
#settingsEmployees .employee-table-frame::after{
  content:"";
  position:absolute;
  inset:0;
  border-radius:12px;
  box-shadow: inset 0 0 0 1px var(--border-soft);
  pointer-events:none;
  z-index: 9999;
}

/* テーブル側は外枠を持たない（外周borderを落として、外枠は ::after に一任） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed{
  border-collapse: separate !important;
  border-spacing: 0 !important;
  background: transparent !important;
  border-radius: 0 !important; /* 角丸はframe側で行う */
  overflow: visible !important;
}

#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed thead tr:first-child th{
  border-top: 0 !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td{
  border-bottom: 0 !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tr > :first-child{
  border-left: 0 !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tr > :last-child{
  border-right: 0 !important;
}

/* 角丸付近の描画にじみ防止 */
#settingsEmployees .employee-table-frame th,
#settingsEmployees .employee-table-frame td{
  background-clip: padding-box;
}

/* v181: 休暇コードタブの削除ボタンを従業員タブと同じサイズ感に */
#settingsLeaveCodes .btn-delete,
#settingsLeaveCodes button.btn-delete{
  width: auto !important;
  min-width: 0 !important;
  max-width: none !important;
  padding: 4px 10px !important;
  white-space: nowrap !important;
}

/* v181: 設定画面の表 行hoverハイライト（薄く、邪魔にならない） */
.settings-panel .settings-table tbody tr:hover > td{
  background: rgba(25,118,210,0.06);
  background: color-mix(in srgb, var(--accent) 7%, transparent);
}
.settings-panel .settings-table tbody tr:hover{
  /* 行の境界が分かりやすいように */
  box-shadow: inset 0 0 0 9999px rgba(25,118,210,0.00);
}
</style>
<style id="v172-employee-grid-lines">
/* v172: 従業員タブ（左表）— 縦罫線を復活 + 横罫線を細く（重なり防止） */

/* 罫線の二重見えを防ぐため、セル罫線は collapse で統合する */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed{
  border-collapse: collapse !important;
}

/* 罫線は 1px に統一（縦も横も表示） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed th,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed td{
  border-width: 1px !important;
}
</style>
<style id="v173-fix-employee-table-gap">
/* v173: 最終行の下にできる隙間を消し、縦罫線の途切れを解消する
   原因：v170で外周セルのborderを0にしていたため、collapse時に縦罫線が下端で途切れて見える。
   対策：外周セルのborderを復活させ、外枠(::after)は背面に回して二重線を避ける。
*/

/* 外枠は背面、テーブルは前面（縦罫線の端が隠れないように） */
#settingsEmployees .employee-table-frame::after{
  z-index: 0 !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed{
  position: relative !important;
  z-index: 1 !important;
}

/* v170で落としていた外周borderを復活させる（これで縦罫線が最終行まで繋がる） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed thead tr:first-child th{
  border-top: 1px solid var(--border-soft) !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td{
  border-bottom: 1px solid var(--border-soft) !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tr > :first-child{
  border-left: 1px solid var(--border-soft) !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tr > :last-child{
  border-right: 1px solid var(--border-soft) !important;
}
</style>
<style id="v174-employee-table-corners-and-lines">
/* v174: 上左右の角欠けを解消（外枠を最前面へ戻す）
   + フッターではなく『最終アイテム行』の角を丸める。
   + 罫線の太さは『二重』にならないよう separate + 片側罫線方式で1px統一。
*/

/* 外枠を最前面に（角欠け防止） */
#settingsEmployees .employee-table-frame::after{
  z-index: 9999 !important;
}

/* テーブルは separate に戻し、border二重を根本回避 */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed{
  border-collapse: separate !important;
  border-spacing: 0 !important;
}

/* いったんセルborderをリセットして、右/下だけ描く（=二重にならない） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed th,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed td{
  border: 0 !important;
  border-right: 1px solid var(--border-soft) !important;
  border-bottom: 1px solid var(--border-soft) !important;
}

/* 外周はoverlay(外枠)に任せるので、外周セルの罫線は落とす */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed thead tr:first-child th{
  border-top: 0 !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td{
  border-bottom: 0 !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tr > :first-child{
  border-left: 0 !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tr > :last-child{
  border-right: 0 !important;
}

/* 角丸は『セル』に付ける（最終アイテム行を丸める） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed thead tr:first-child th:first-child{
  border-top-left-radius: 12px !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed thead tr:first-child th:last-child{
  border-top-right-radius: 12px !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:first-child{
  border-bottom-left-radius: 12px !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:last-child{
  border-bottom-right-radius: 12px !important;
}

/* 角丸セルの背景が透けて『欠け』に見えないように */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed thead th,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody td{
  background-clip: padding-box;
}
</style>
<style id="v175-bottom-corner-cells">
/* v175: 最終行の左下/右下の角を“セル”で角丸にする */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:first-child{
  border-bottom-left-radius: 12px !important;
  overflow: hidden !important;
  background: #fff !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:last-child{
  border-bottom-right-radius: 12px !important;
  overflow: hidden !important;
  background: #fff !important;
}
</style>
<style id="v177-round-bottom-like-header">
/* v177: 最終行の左下/右下をヘッダー行と同じように“セルで”角丸にする */

/* frame内のtableは余白を持たない（最終行の後の“隙間”に見えるのを防止） */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed{
  margin: 0 !important;
}

/* 最終行の角セルを確実に角丸＋クリップ */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:first-child,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:last-child{
  position: relative !important;
  overflow: hidden !important;
  background: #fff !important; /* 角の欠け/にじみ防止 */
}

#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:first-child{
  border-bottom-left-radius: 12px !important;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:last-child{
  border-bottom-right-radius: 12px !important;
}

/* セル背景が透明だと角丸が視覚的に出にくいケースがあるため、内側に背景レイヤーを敷く */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:first-child::before{
  content:"";
  position:absolute;
  inset:0;
  border-bottom-left-radius:12px;
  background:#fff;
  pointer-events:none;
  z-index:0;
}
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:last-child::before{
  content:"";
  position:absolute;
  inset:0;
  border-bottom-right-radius:12px;
  background:#fff;
  pointer-events:none;
  z-index:0;
}

/* セル内容は背景レイヤーより前に */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:first-child > *,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:last-child td:last-child > *{
  position: relative;
  z-index: 1;
}

</style>
<style id="v182-fixes-hover-and-leave-delete">
/* v182: 休暇コード(Leave Codes)の削除ボタン高さを従業員タブと同じに寄せる */
#settingsLeaveCodes .btn-delete,
#settingsLeaveCodes button.btn-delete{
  width: auto !important;
  min-width: 0 !important;
  max-width: none !important;

  /* ラベル上下の余白をなくして高さを抑える */
  box-sizing: border-box !important;
  height: 28px !important;
  min-height: 28px !important;
  padding: 0 10px !important;
  font-size: 12px !important;
  border-radius: 10px !important;
  line-height: 1 !important;

  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  white-space: nowrap !important;
}

/* v182: 従業員タブの最終行角セルは ::before 背景を敷いているため、
   行hover時にその背景も一緒に色を変えて、角セルだけハイライトされない問題を解消する */
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:hover td:first-child::before,
#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed tbody tr:hover td:last-child::before{
  background: color-mix(in srgb, var(--accent) 7%, #fff) !important;
}

</style>

<script id="v156-equal-diff-distribution">
/* v156: 2〜6列の幅差（余り/不足）を等分で配分する
   delta = (テーブルの表示幅 - 1列目 - 基準合計) / 5
   ただし、縮小しすぎて入力が潰れないように最小幅を考慮してクランプする。
*/
(function(){
  function px(n){ return Math.round(n*100)/100; }

  function updateEmployeeCols(){
    const table = document.querySelector('#settingsEmployees .employee-table-frame table.settings-table.employee-table-fixed');
    if(!table) return;

    const cs = getComputedStyle(table);

    // 基準幅
    const drag = parseFloat(cs.getPropertyValue('--emp-drag')) || 28;
    const bases = [
      parseFloat(cs.getPropertyValue('--emp-c2')) || 80,
      parseFloat(cs.getPropertyValue('--emp-c3')) || 80,
      parseFloat(cs.getPropertyValue('--emp-c4')) || 140,
      parseFloat(cs.getPropertyValue('--emp-c5')) || 80,
      parseFloat(cs.getPropertyValue('--emp-c6')) || 60,
    ];

    // 最小幅（実務的に入力UIが潰れない程度。必要なら調整してください）
    const mins = [60, 60, 100, 60, 60];

    // テーブル表示幅（border込みの見た目幅を採用）
    const rect = table.getBoundingClientRect();
    const tableW = rect.width;

    // deltaを等分計算
    const baseSum = bases.reduce((a,b)=>a+b,0);
    let diff = tableW - drag - baseSum;
    let delta = diff / bases.length;

    // ただし、マイナス方向で最小幅を割り込むなら、割り込まない範囲までクランプ
    // （全列同じdeltaを維持しつつ、限界を超えたらそこで止める）
    let minAllowedDelta = Infinity;
    for(let i=0;i<bases.length;i++){
      minAllowedDelta = Math.min(minAllowedDelta, mins[i] - bases[i]);
    }
    if(delta < minAllowedDelta) delta = minAllowedDelta;

    // デカすぎる増加も抑制（極端に広い画面で不自然になりすぎないように）
    // 上限を外したいならこの行をコメントアウト
    const maxAllowedDelta = 240; // 例：+240px/列まで
    if(delta > maxAllowedDelta) delta = maxAllowedDelta;

    table.style.setProperty('--emp-delta', px(delta) + 'px');
  }

  // 初期化＆リサイズ追従
  window.addEventListener('resize', updateEmployeeCols, {passive:true});
  // タブ表示直後など、レイアウト確定後にもう一回
  setTimeout(updateEmployeeCols, 0);
  setTimeout(updateEmployeeCols, 200);

  // 可能なら ResizeObserver でコンテナ幅変化にも追従
  if('ResizeObserver' in window){
    const ro = new ResizeObserver(()=>updateEmployeeCols());
    const container = document.querySelector('#settingsEmployees .employee-col-left');
    if(container) ro.observe(container);
    ro.observe(document.documentElement);
  }
})();
</script>
<style id="v154-fix-left-employee-col-width-and-no-scroll">
/* v154: 従業員タブ 左表
   目的:
   - 先頭列(ドラッグ列)は常に 28px（=セルの見た目も28px）
   - それ以外の列は「残り幅(100% - 28px)」の中で割合配分して伸縮
   - 横スクロールは発生させない（テーブルを親幅に収める）
   背景:
   - v110 の width:100% + table-layout:fixed はOKだが、%列の合計(90%)に 28px を足すと
     狭い幅で破綻し、28px列まで再配分で太ったり潰れたりする
   - v153 の max-content/min-width により横スクロールが発生していた
*/

/* 横スクロール禁止（テーブルを親幅に収める） */
#settingsEmployees .employee-col-left{
  overflow-x:hidden !important;
}

/* テーブルは親幅に合わせ、固定レイアウトで colgroup を確実に反映 */
#settingsEmployees table.settings-table.employee-table-fixed{
  width:100% !important;
  min-width:0 !important;
  table-layout:fixed !important;
}

/* 先頭列は 28px 固定（col + セル） */
#settingsEmployees table.settings-table.employee-table-fixed colgroup col:nth-child(1){
  width:28px !important;
  min-width:28px !important;
  max-width:28px !important;
}
#settingsEmployees table.settings-table.employee-table-fixed thead th:first-child,
#settingsEmployees table.settings-table.employee-table-fixed tbody td:first-child{
  width:28px !important;
  min-width:28px !important;
  max-width:28px !important;
  box-sizing:border-box !important;
  padding:0 !important;            /* padding分で太って見えるのを防ぐ */
  overflow:hidden !important;
  text-overflow:clip !important;
  white-space:nowrap !important;
  text-align:center !important;
}

/* 残り列は「(100% - 28px)」の中で割合配分
   ※ col の inline style(18%等) を !important で上書きする
*/
#settingsEmployees table.settings-table.employee-table-fixed colgroup col:nth-child(2){
  width:calc((100% - 28px) * 0.18) !important;
}
#settingsEmployees table.settings-table.employee-table-fixed colgroup col:nth-child(3){
  width:calc((100% - 28px) * 0.18) !important;
}
#settingsEmployees table.settings-table.employee-table-fixed colgroup col:nth-child(4){
  width:calc((100% - 28px) * 0.30) !important;
}
#settingsEmployees table.settings-table.employee-table-fixed colgroup col:nth-child(5){
  width:calc((100% - 28px) * 0.12) !important;
}
#settingsEmployees table.settings-table.employee-table-fixed colgroup col:nth-child(6){
  width:calc((100% - 28px) * 0.12) !important;
}

/* ドラッグハンドルやセル内要素が列幅を押し広げないようにする */
#settingsEmployees table.settings-table.employee-table-fixed .emp-drag-cell,
#settingsEmployees table.settings-table.employee-table-fixed .emp-drag-handle{
  width:28px !important;
  min-width:28px !important;
  max-width:28px !important;
  box-sizing:border-box !important;
}
#settingsEmployees table.settings-table.employee-table-fixed .emp-drag-handle{
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  padding:0 !important;
}
</style>
<!-- v159: center grip icon vertically in drag column (employees tab left table) -->
<style id="v159-center-grip-icon">
  /* 1列目（ドラッグ列）セルを縦中央揃えにする */
  #settingsEmployees .employee-col-left table.employee-table-fixed td.emp-drag-cell,
  #settingsEmployees .employee-col-left table.employee-table-fixed th.employee-drag-handle{
    padding: 0 !important;
    vertical-align: middle !important;
  }
  #settingsEmployees .employee-col-left table.employee-table-fixed td.emp-drag-cell{
  /* v160: keep table-cell sizing; center content vertically without shrinking the row */
  padding: 0 !important;
  text-align: center !important;
  vertical-align: middle !important;
}
  #settingsEmployees .employee-col-left table.employee-table-fixed td.emp-drag-cell .emp-drag-handle{
  /* v160: match row control height and keep icon centered */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: 32px;  /* matches input/select/button height (v158) */
  line-height: 1;
  cursor: grab;
}
</style>
<!-- v187: employee row height 28px + delete button radius match holiday (10px) -->
<style>
/* === v187 override: Employees tab row/input/button height = 28px === */
#settingsEmployees table.settings-table.employee-table-fixed input,
#settingsEmployees table.settings-table.employee-table-fixed select{
  height: 28px !important;
}

#settingsEmployees table.settings-table.employee-table-fixed button{
  height: 28px !important;
  min-height: 28px !important;
  padding-top: 0 !important;
  padding-bottom: 0 !important;
  line-height: 1 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  box-sizing: border-box !important;
}

/* Drag handle cell height align */
#settingsEmployees td .emp-drag-handle,
#settingsEmployees td.employee-drag-handle,
#settingsEmployees td.emp-drag-cell{
  min-height: 28px !important;
}

/* === v187 override: Delete button radius match Holiday tab === */
#settingsEmployees .btn-delete,
#settingsEmployees button.btn-delete{
  border-radius: 10px !important;
}
</style>
<style>

/* v189: Stores tab delete button match Leave/Employee (28px + radius 10px) */
#settingsStores button.btn-delete{
  height: 28px !important;
  min-height: 28px !important;
  padding: 0 10px !important;
  line-height: 1 !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  box-sizing: border-box !important;
  border-radius: 10px !important;
  white-space: nowrap;
}


/* v197: 店舗内順は表示のみ（1刻み） */
#settingsEmployees .emp-order[readonly]{
  background: transparent;
  border-color: transparent;
  text-align: right;
  pointer-events: none; /* クリックで編集できない */
  color: var(--text-muted, #556);
}

</style>
</head>
<body>
<header>
<div class="header-left">
<div class="app-title">勤務予定表 入力アプリ</div>
<div class="field-group">
<label for="storeSelect">店舗</label>
<select id="storeSelect"></select>
</div>
<div class="field-group">
<label for="monthInput">年月</label>
<input id="monthInput" type="month"/>
</div>
</div>
<div class="header-right">
<label class="toggle" id="autoSaveToggle">
<div class="toggle-pill"><div class="toggle-thumb"></div></div>
<span>自動保存</span>
</label>
<button class="primary" disabled="" id="saveButton">保存</button>
<button id="exportButton">出力</button>
<button class="icon" id="settingsButton" title="マスタ設定">⚙ 設定</button>
<button class="icon" id="debugButton" title="デバッグ">🐞</button>
</div>
</header>
<div class="app-main">
<aside class="sidebar">
<div class="sidebar-section">
<h3>入力モード</h3>
<div class="sidebar-row"><span>コード種別</span><span class="badge work" id="modeBadge">業務コード</span></div>
<small>Ctrlキーを<strong>押している間だけ</strong>休暇コード入力になります。</small>
<div class="divider"></div>
<div class="sidebar-row"><span>応援先</span></div>
<select id="supportStoreSelect"></select>
<small>自店舗以外を選択すると「応援入力（先頭に略称）」になります。</small>
</div>
<div class="sidebar-section">
<h3>コード入力パレット</h3>
<div class="keypad" id="keypad"></div>
<small>テンキー（1〜9）でも同じ配置で入力できます。</small>
<div class="ime-alert" id="imeAlert">日本語入力(IME)がオンの可能性があります。英数入力に切り替えてください。</div>
</div>
<div class="sidebar-section">
<h3>夜勤・整合チェック</h3>
<small>夜勤は「ﾃ（入り）」と「ﾋ（明け）」がセットです。月末ﾃは翌月1日に自動反映（翌月チェックなし）。</small>
<div class="alert-list" id="alertList"></div>
</div>
<div class="sidebar-section" id="debugSection" style="display:none;">
<h3>デバッグ</h3>
<small>入力できない原因の切り分け用です（Ctrl+Shift+Dでも表示切替）。</small>
<div class="divider"></div>
<div id="debugInfo" style="font-size:11px;line-height:1.45;color:var(--text-muted);"></div>
<div class="divider"></div>
<div class="settings-inline-controls">
<button id="dbgExport" title="現在のデータをJSONとして保存">データ書き出し</button>
<button id="dbgCopyState" title="状態のJSONをクリップボードへ">状態コピー</button>
<button class="primary" id="dbgFixSnapshot" title="この年月のスナップショットを最新マスタで更新">今月ルール更新</button>
<button class="text-danger" id="dbgReset" title="全データ初期化（元に戻せません）">全初期化</button>
</div>
<small class="text-muted">「今月ルール更新」は “この年月だけ” の入力ルール（店舗の業務コード有効/夜勤）を最新マスタで上書きします。</small>
</div>
</aside>
<main>
<div class="schedule-header"><div class="schedule-title" id="scheduleTitle"></div></div>
<div class="schedule-wrapper">
<div class="schedule-inner" id="scheduleInner">
<div class="notice" id="schedulePlaceholder">「設定」から店舗・従業員を登録し、年月を選択して勤務表を作成してください。</div>
</div>
</div>
</main>
</div>
<!-- Settings Modal -->
<div class="modal-backdrop" id="settingsModalBackdrop">
<div class="modal">
<div class="modal-header">
<h2>マスタ設定</h2>
<button class="icon" id="settingsCloseButton">✕</button>
</div>
<div class="modal-body">
<div class="notice" id="settingsScopeNote" style="margin-bottom:10px;">
        既に作成済みの年月を開いている場合は「この年月のマスタ」を編集します。未作成の年月の場合は「今後の新規作成用マスタ」を編集します。
      </div>
<div class="notice" id="propagateToTemplateWrap" style="display:none; margin-bottom:10px;">
<label style="display:flex; align-items:center; gap:8px; user-select:none;">
<input checked="" id="propagateToTemplateCheckbox" type="checkbox"/>
<span>この変更を新規作成時にも反映</span>
</label>
<div class="text-muted" style="margin-top:6px;">※ 最新の勤務表を開いている場合のみ、次回以降の新規作成に反映できます。</div>
</div>
<div class="modal-tabs">
<div class="modal-tab active" data-target="settingsStores">店舗</div>
<div class="modal-tab" data-target="settingsEmployees">従業員</div>
<div class="modal-tab" data-target="settingsWorkCodes">業務コード</div>
<div class="modal-tab" data-target="settingsLeaveCodes">休暇コード</div>
</div>
<div class="settings-panels">
<div class="settings-panel active" id="settingsStores">
<p class="text-muted">店舗名・略称はユニーク。勤務表データがある店舗は削除できず無効化してください。</p>
<div class="settings-table-frame"><table class="settings-table">
<thead><tr>
<th style="width:120px;">並び</th><th>店舗名</th><th style="width:90px;">略称</th><th style="width:70px;">有効</th>
<th>業務コード（日勤/夜勤/無効）</th><th style="width:90px;">削除</th>
</tr></thead>
<tbody id="storeTableBody"></tbody>
</table></div>
<button id="addStoreButton" class="add-link-btn">店舗を追加</button>
</div>
<div class="settings-panel" id="settingsEmployees">
<p class="text-muted">同姓同名は不可。勤務表データがある従業員は削除不可（未所属へ）。</p>
<div class="employee-two-col">
<div class="employee-col employee-col-left">
<div class="employee-table-frame">
<table class="settings-table employee-table-fixed">
<colgroup>
<col class="drag-col" style="width:28px"/>
<col style="width:18%"/>
<col style="width:18%"/>
<col style="width:30%"/>
<col style="width:12%"/>
<col style="width:12%"/>
</colgroup>
<thead><tr>
<th class="employee-drag-handle" title="ドラッグして店舗へ追加"> </th>
<th style="width:160px;">姓</th><th style="width:160px;">名</th><th>所属店舗</th><th style="width:110px;">店舗内順</th><th style="width:90px;">削除</th>
</tr></thead>
<tbody id="employeeTableBody"></tbody>
</table>
</div>
<button id="addEmployeeButton" class="add-link-btn">従業員を追加</button>
</div>
<div class="employee-col employee-col-right">
<div class="employee-order-head">
<div class="employee-order-row">
<div class="label">店舗</div>
<select id="employeeOrderStoreSelect"></select>
</div>
</div>
<div class="employee-order-list" id="employeeOrderList"></div>
</div>
</div>
</div>
<div class="settings-panel" id="settingsWorkCodes">
<p class="text-muted">業務コードはA〜F。テンキー割当と色を設定します。</p>
<div class="settings-table-frame"><table class="settings-table">
<thead><tr><th style="width:80px;">コード</th><th style="width:120px;">テンキー</th><th style="width:120px;">文字色</th><th style="width:120px;">背景色（薄）</th></tr></thead>
<tbody id="workCodeTableBody"></tbody>
</table></div>
</div>
<div class="settings-panel" id="settingsLeaveCodes">
<p class="text-muted">休暇コード（全店舗共通）。追加・削除可。</p>
<div class="settings-table-frame"><table class="settings-table">
<thead><tr><th>コード</th><th style="width:120px;">テンキー</th><th style="width:90px;">削除</th></tr></thead>
<tbody id="leaveCodeTableBody"></tbody>
</table></div>
<button id="addLeaveCodeButton" class="add-link-btn">休暇コードを追加</button>
</div>
</div>
</div>
<div class="modal-footer">
<span class="text-muted" style="margin-right:auto;font-size:11px;">※ マスタ変更は基本「この月の勤務表」にのみ反映されます。最新の勤務表ではチェックONで次回以降の新規作成にも反映できます。</span>
<button class="primary" id="settingsSaveButton">マスタを保存</button>
<button id="settingsCancelButton">閉じる</button>
</div>
</div>
</div>
<!-- Unsaved Modal -->
<div class="modal-backdrop" id="unsavedModalBackdrop">
<div class="modal" style="max-width:460px;">
<div class="modal-header"><h2>未保存の変更があります</h2></div>
<div class="unsaved-body">
<p>勤務表に未保存の変更があります。どうしますか？</p>
<ul>
<li><strong>保存して移動</strong> … 現在の変更を保存してから移動します。</li>
<li><strong>破棄して移動</strong> … 現在の変更を破棄して移動します。</li>
<li><strong>キャンセル</strong> … 移動を中止します。</li>
</ul>
</div>
<div class="modal-footer">
<button class="text-danger" id="unsavedDiscardButton">破棄して移動</button>
<button class="primary" id="unsavedSaveButton">保存して移動</button>
<button id="unsavedCancelButton">キャンセル</button>
</div>
</div>
</div>
<!-- New Schedule Modal -->
<div class="modal-backdrop" id="newScheduleModalBackdrop">
<div class="modal" style="max-width:480px;">
<div class="modal-header"><h2>勤務表を新規作成</h2></div>
<div class="unsaved-body">
<p id="newScheduleMessage"></p>
<p>作成前にマスタを確認・修正できます。問題なければ有効な全店舗分をまとめて作成します。</p>
</div>
<div class="modal-footer">
<button id="newScheduleWithSettingsButton">マスタを確認して作成</button>
<button class="primary" id="newScheduleDirectButton">現在のマスタで作成</button>
<button id="newScheduleCancelButton">キャンセル</button>
</div>
</div>
</div>
<script>
/* ===========
  このファイルは「構文エラーが出ない完全版」をsandbox上で生成したものです。
  以前のコピペで途切れていた場合、こちらに差し替えるだけで Unexpected end of input は解消します。
=========== */

const STORAGE_KEY = "workScheduleApp_v2";
let appState=null;

let currentYearMonth=null;
let currentStoreId=null;
let currentSchedule=null;
let currentStoreSchedule=null;

let ctrlDown=false;
let isSupportMode=false;

let dragSelecting=false; // 範囲選択中（ドラッグ中）
let pointerDown=false;   // 左クリック押下中
let didDrag=false;       // 実際にセルをまたいでドラッグしたか
let dragJustEnded=false; // ドラッグ直後の click で選択が潰れるのを防ぐ
let dragAdditive=false;  // Ctrl/Metaドラッグ：既存選択に追加
let lastMouseDownAdditive=false; // 直近mousedownがCtrl/Metaだったか（focusイベント対策）
let ctrlTogglePending=false; // Ctrl/Meta時：クリックならトグル、ドラッグなら矩形（判定待ち）
let ctrlPendingCell=null;
let dragRangeMode='replace'; // 'replace' | 'add' | 'remove'
let dragRangeModeStart='replace'; // デバッグ用：開始時のモード
let dragStartX=0, dragStartY=0; // ドラッグ開始座標
let dragLastRectKeys=null; // Ctrlドラッグ中の矩形キー集合（確定用）
let shiftAnchorCell=null; // Shift+矢印 範囲選択の起点
let suppressShiftAnchorReset=false; // Shift範囲選択中の anchor リセット抑止

let dragStartCell=null;
let dragMoveCount=0;
let dragLastHit=null;
let dragEventLog=[]; // {t,type,buttons,button,code,key,target,td}
function logDragEvent(ev){
  dragEventLog.push(ev);
  if(dragEventLog.length>40) dragEventLog.shift();
}

let selectedCells=[];

let selectedKeySet=new Set();
let preserveSelectionOnRender=false;
let preserveSelectionKeys=null;
let preserveSelectionActiveKey=null;
let activeCell=null;

// ===== Keyboard Debug =====
const __KEY_DEBUG__ = { enabled:true, max:80, events:[] };
function safeCellKeyMaybe(cell){
  try{
    if(!cell) return null;
    const td = (cell.tagName==="TD")?cell:cell.closest?.("td");
    return td ? cellKey(td) : null;
  }catch(_){ return null; }
}
function dbgKey(stage, e, extra){
  try{
    if(!__KEY_DEBUG__.enabled) return;
    const entry = {
      t: Date.now(),
      stage,
      key: e?.key,
      code: e?.code,
      shift: !!e?.shiftKey,
      ctrl: !!e?.ctrlKey,
      meta: !!e?.metaKey,
      alt: !!e?.altKey,
      composing: !!e?.isComposing,
      defaultPrevented: !!e?.defaultPrevented,
      target: e?.target?.tagName || null,
      activeEl: document.activeElement?.tagName || null,
      activeCell: safeCellKeyMaybe((()=>{try{return activeCell;}catch(_){return null;}})()),
      anchor: safeCellKeyMaybe((()=>{try{return shiftAnchorCell;}catch(_){return null;}})()),
      extra: extra || null
    };
    __KEY_DEBUG__.events.push(entry);
    if(__KEY_DEBUG__.events.length > __KEY_DEBUG__.max){
      __KEY_DEBUG__.events.splice(0, __KEY_DEBUG__.events.length-__KEY_DEBUG__.max);
    }
    try{
      if(typeof dragEventLog!=="undefined" && Array.isArray(dragEventLog)){
        dragEventLog.push({t:Date.now(), type:"key", stage, key:e?.key, code:e?.code, shift:!!e?.shiftKey, ctrl:!!e?.ctrlKey, meta:!!e?.metaKey, alt:!!e?.altKey, composing:!!e?.isComposing, prevented:!!e?.defaultPrevented, extra: extra||null});
        if(dragEventLog.length>200) dragEventLog.splice(0, dragEventLog.length-200);
      }
    }catch(_){ }
    if(typeof renderDebugInfo==="function") renderDebugInfo();
  }catch(_){}
}
window.__KEY_DEBUG__ = __KEY_DEBUG__;
// capture all keydown for troubleshooting
window.addEventListener("keydown",(e)=>{ dbgKey("cap-all", e, null); }, true);

// ===== Settings DnD Debug (always visible in Console) =====
// 「何も表示されない」= dragstart/drop が発火していない可能性が高いため、
// ネイティブDnDイベントをグローバルに捕捉してコンソールに出す。
window.addEventListener("dragstart", (e)=>{
  try{ console.debug("[dnd] dragstart", {tag:e.target?.tagName, cls:e.target?.className, id:e.target?.id}); }catch(_){ }
}, true);
window.addEventListener("dragover", (e)=>{
  try{ console.debug("[dnd] dragover", {tag:e.target?.tagName, cls:e.target?.className, id:e.target?.id}); }catch(_){ }
}, true);
window.addEventListener("drop", (e)=>{
  try{ console.debug("[dnd] drop", {tag:e.target?.tagName, cls:e.target?.className, id:e.target?.id}); }catch(_){ }
}, true);

let dirty=false;
let pendingNavigationTarget=null;
let pendingFocus=null;

let imeAlertTimer=null;

const dom={};

document.addEventListener("DOMContentLoaded",()=>{
  cacheDom();
  initState();
  initHeader();
  initSidebar();
  initModals();
  initDebugTools();
  loadInitialContext();
  renderAll();
  markDropZones();
});

// v119: markDropZones() が未定義だと初期化で停止し、設定画面DnDが動かない。
// ここでは安全なno-opとして定義しておき、必要な初期化は各パネル描画時に行う。
function markDropZones(){
  try{
    // 右側パネルは refreshEmployeeOrderPanel() 内でdropzone生成＋DnD初期化される
    // ここは ReferenceError を避けるための保険。初期化関数があれば呼ぶ。
    if(typeof ensureEmployeeOrderDnDInitialized==="function") ensureEmployeeOrderDnDInitialized();
  }catch(_e){}
}

function cacheDom(){
  dom.storeSelect=document.getElementById("storeSelect");
  dom.monthInput=document.getElementById("monthInput");
  dom.autoSaveToggle=document.getElementById("autoSaveToggle");
  dom.saveButton=document.getElementById("saveButton");  dom.exportButton=document.getElementById("exportButton");
  dom.settingsButton=document.getElementById("settingsButton");
dom.supportStoreSelect=document.getElementById("supportStoreSelect");
  dom.modeBadge=document.getElementById("modeBadge");
  dom.keypad=document.getElementById("keypad");
  dom.imeAlert=document.getElementById("imeAlert");
  dom.scheduleTitle=document.getElementById("scheduleTitle");
  dom.scheduleInner=document.getElementById("scheduleInner");
  dom.schedulePlaceholder=document.getElementById("schedulePlaceholder");
  dom.alertList=document.getElementById("alertList");

  dom.settingsModalBackdrop=document.getElementById("settingsModalBackdrop");
  dom.settingsCloseButton=document.getElementById("settingsCloseButton");
  dom.settingsSaveButton=document.getElementById("settingsSaveButton");
  dom.settingsCancelButton=document.getElementById("settingsCancelButton");
  dom.storeTableBody=document.getElementById("storeTableBody");
  dom.employeeTableBody=document.getElementById("employeeTableBody");
  dom.employeeOrderStoreSelect=document.getElementById("employeeOrderStoreSelect");
  dom.employeeOrderList=document.getElementById("employeeOrderList");
  // 右ペイン：店舗セレクト切替で即再描画
  dom.employeeOrderStoreSelect?.addEventListener("change", ()=>{ refreshEmployeeOrderPanel(); });
  // 店舗タブの変更を従業員タブの所属店舗プルダウンに即反映（設定モーダル内で完結させる）
  let __storeChangeRaf = null;
  const __onStoreChange = ()=>{
    if(__storeChangeRaf) cancelAnimationFrame(__storeChangeRaf);
    __storeChangeRaf = requestAnimationFrame(()=>{refreshEmployeeStoreOptionsFromSettings(); refreshEmployeeOrderPanel();});
  };
  dom.storeTableBody.addEventListener("input", __onStoreChange);
  dom.storeTableBody.addEventListener("change", __onStoreChange);

  dom.workCodeTableBody=document.getElementById("workCodeTableBody");
  dom.leaveCodeTableBody=document.getElementById("leaveCodeTableBody");
  dom.addStoreButton=document.getElementById("addStoreButton");
  dom.addEmployeeButton=document.getElementById("addEmployeeButton");
  dom.addLeaveCodeButton=document.getElementById("addLeaveCodeButton");

  dom.unsavedModalBackdrop=document.getElementById("unsavedModalBackdrop");
  dom.unsavedDiscardButton=document.getElementById("unsavedDiscardButton");
  dom.unsavedSaveButton=document.getElementById("unsavedSaveButton");
  dom.unsavedCancelButton=document.getElementById("unsavedCancelButton");

  dom.newScheduleModalBackdrop=document.getElementById("newScheduleModalBackdrop");
  dom.newScheduleMessage=document.getElementById("newScheduleMessage");
  dom.newScheduleWithSettingsButton=document.getElementById("newScheduleWithSettingsButton");
  dom.newScheduleDirectButton=document.getElementById("newScheduleDirectButton");
  dom.newScheduleCancelButton=document.getElementById("newScheduleCancelButton");

  dom.debugButton=document.getElementById("debugButton");
  dom.debugSection=document.getElementById("debugSection");
  dom.debugInfo=document.getElementById("debugInfo");
  dom.debugDragLog=document.getElementById("debugDragLog");
  dom.dragHint=document.getElementById('dragHint');
  dom.dragHintText=document.getElementById('dragHintText');
  dom.dragHintPill=document.getElementById('dragHintPill');
  dom.dbgExport=document.getElementById("dbgExport");
  dom.dbgCopyState=document.getElementById("dbgCopyState");
  dom.dbgFixSnapshot=document.getElementById("dbgFixSnapshot");
  dom.dbgReset=document.getElementById("dbgReset");
}

function initState(){
  const saved=localStorage.getItem(STORAGE_KEY);
  if(saved){
    try{ appState=JSON.parse(saved); }
    catch(e){ console.error("保存データ読込失敗。初期化します。",e); appState=createDefaultState(); }
  }else{
    appState=createDefaultState();
  }
  if(!appState.pendingNightCarryovers) appState.pendingNightCarryovers={};
  persistState();
}

function createDefaultState(){
  const workCodes=[
    {code:"A",key:"7",color:"#e11d48",bgColor:lightenColor("#e11d48",0.86)},
    {code:"B",key:"8",color:"#1976d2",bgColor:lightenColor("#1976d2",0.86)},
    {code:"C",key:"9",color:"#f59e0b",bgColor:lightenColor("#f59e0b",0.88)},
    {code:"D",key:"4",color:"#16a34a",bgColor:lightenColor("#16a34a",0.88)},
    {code:"E",key:"5",color:"#ca8a04",bgColor:lightenColor("#ca8a04",0.90)},
    {code:"F",key:"6",color:"#7c3aed",bgColor:lightenColor("#7c3aed",0.86)},
  ];
  const leaveCodes=[
    {code:"特",key:"7"},{code:"調",key:"8"},{code:"公",key:"9"},{code:"年",key:"4"},{code:"病気",key:"5"},{code:"休",key:"6"},
  ];
  return {
    settings:{ autoSave:true, lastStoreId:null, lastYearMonth:null },
    templateMaster:{
      nextStoreId:1,nextEmployeeId:1,
      stores:[],
      employees:[],
      workCodes, leaveCodes
    },
    schedules:{},
    pendingNightCarryovers:{}
  };
}

function persistState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(appState)); }

/* ===== Header ===== */
function initHeader(){
  dom.monthInput.addEventListener("change", ()=>{
    const ym=dom.monthInput.value||null;
    if(!ym) return;
    navigateTo(currentStoreId, ym);
  });

  dom.storeSelect.addEventListener("change", ()=>{
    const storeId=Number(dom.storeSelect.value||"0")||null;
    navigateTo(storeId, currentYearMonth);
  });

  dom.autoSaveToggle.addEventListener("click", ()=>{
    const newVal=!appState.settings.autoSave;
    appState.settings.autoSave=newVal;
    updateAutoSaveToggleUI();
    if(newVal){
      persistState();
      dirty=false;
      updateSaveButton();
    }
  });

  dom.saveButton.addEventListener("click", ()=>{
    if(!dirty) return;
    persistState();
    dirty=false;
    updateSaveButton();
  });
  dom.exportButton.addEventListener("click", ()=>{
    const schedule=getCurrentSchedule();
    if(!schedule) return;
    openPrintWindowForMonth(schedule,getStoreIdsInSchedule(schedule));
  });

  dom.settingsButton.addEventListener("click", ()=>openSettingsModal(null));


  window.addEventListener("beforeunload",(e)=>{
    if(!appState.settings.autoSave && dirty){
      e.preventDefault();
      e.returnValue="";
    }
  });
}

/* ===== Sidebar / Keys ===== */
function initSidebar(){
  dom.supportStoreSelect.addEventListener("change", ()=>{
    const val=dom.supportStoreSelect.value;
    isSupportMode = val !== "self";
    renderKeypad();
  });

  
  // WS_SHIFT_ARROW_WINDOW: Shift+矢印を最優先で捕捉（他のkeydownハンドラに奪われないよう window/capture で処理）
  window.addEventListener("keydown",(e)=>{
    dbgKey("wshift-enter", e, null);
    if(e.isComposing || e.key==="Process"){ dbgKey("wshift-exit", e, {reason:"composing"}); return; }
    if(!e.shiftKey || e.ctrlKey || e.metaKey){ dbgKey("wshift-exit", e, {reason:"modifiers"}); return; }
    if(!(e.key==="ArrowLeft"||e.key==="ArrowRight"||e.key==="ArrowUp"||e.key==="ArrowDown")){ dbgKey("wshift-exit", e, {reason:"not-arrow"}); return; }

    // activeCell が無い場合は activeElement から推測（contenteditable対策）
    if(!activeCell){
      const td = document.activeElement?.closest?.("td");
      if(td){ setActiveCell(td); }
    }
    if(!activeCell){ dbgKey("wshift-exit", e, {reason:"no-activeCell"}); return; }

    const activeTd = (activeCell.tagName==="TD") ? activeCell : activeCell.closest?.("td");
    if(activeTd?.dataset?.rowType==='note'){ dbgKey('wshift-exit', e, {reason:'note-row'}); return; }
    if(!activeTd){ dbgKey("wshift-exit", e, {reason:"active-not-td"}); return; }

    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    dbgKey("wshift-stop", e, null);

    if(!shiftAnchorCell) shiftAnchorCell = activeTd;
    const anchorTd = (shiftAnchorCell.tagName==="TD") ? shiftAnchorCell : shiftAnchorCell.closest?.("td");
    if(!anchorTd){ shiftAnchorCell = activeTd; }

    const rowType = (shiftAnchorCell.tagName==="TD" ? shiftAnchorCell : activeTd).dataset.rowType;
    const maxDay = getVisibleMaxDay();
    const rowList = getRowIndexList(rowType);

    const curRow = parseInt(activeTd.dataset.rowIndex,10);
    const curDay = parseInt(activeTd.dataset.day,10);
    let r = curRow;
    let d = curDay;

    if(e.key==="ArrowLeft")  d = Math.max(1, d-1);
    if(e.key==="ArrowRight") d = Math.min(maxDay, d+1);

    if(e.key==="ArrowUp"||e.key==="ArrowDown"){
      const idx = rowList.indexOf(curRow);
      if(idx !== -1){
        const nextIdx = e.key==="ArrowUp" ? Math.max(0, idx-1) : Math.min(rowList.length-1, idx+1);
        r = rowList[nextIdx];
      }else{
        r = rowList[0];
      }
    }

    const next = getCellByRowDay(rowType, r, d);
    dbgKey("wshift-move", e, {rowType, curRow, curDay, nextRow:r, nextDay:d, nextFound:!!next, rowListLen:rowList.length, maxDay});
    if(!next){ dbgKey("wshift-exit", e, {reason:"next-null"}); return; }

    const rectKeys = buildRectKeys(shiftAnchorCell, next);
    dbgKey("wshift-rect", e, {rectSize: rectKeys.size, anchor: cellKey(shiftAnchorCell), next: cellKey(next)});
    suppressShiftAnchorReset=true;
    pointerDown = false;
    applySelectionKeys(rectKeys, next);
    try{ next.focus({preventScroll:true}); }catch(_){ try{ next.focus(); }catch(__){} }
        suppressShiftAnchorReset=false;
dbgKey("wshift-done", e, null);
  }, true);

document.addEventListener("keyup",(e)=>{ if(e.key==="Shift"){ shiftAnchorCell=null; } });

// Ctrlキーで「業務↔休暇」パレット切替（押下中のみ休暇モード）
document.addEventListener("keydown",(e)=>{
  // 右Ctrl/左Ctrlどちらも
  if(e.key==="Control"){
    if(!ctrlDown){
      ctrlDown=true;
      dbgKey("ctrl-down", e, null);
      try{ renderKeypad(); }catch(_){}
    }
  }
}, true);

document.addEventListener("keyup",(e)=>{
  if(e.key==="Control"){
    if(ctrlDown){
      ctrlDown=false;
      dbgKey("ctrl-up", e, null);
      try{ renderKeypad(); }catch(_){}
    }
  }
}, true);

// ブラウザ外にフォーカスが移った場合など：取りこぼし防止
window.addEventListener("blur", ()=>{
  if(ctrlDown){
    ctrlDown=false;
    try{ renderKeypad(); }catch(_){}
  }
  if(typeof shiftAnchorCell!=="undefined"){ shiftAnchorCell=null; }
}, true);
document.addEventListener("keydown",(e)=>{
    dbgKey("shift-enter", e, null);
    if(e.isComposing || e.key==="Process"){ dbgKey("shift-exit", e, {reason:"composing"}); return; }
    if(!e.shiftKey || e.ctrlKey || e.metaKey){ dbgKey("shift-exit", e, {reason:"modifiers"}); return; }
    if(!(e.key==="ArrowLeft"||e.key==="ArrowRight"||e.key==="ArrowUp"||e.key==="ArrowDown")){ dbgKey("shift-exit", e, {reason:"not-arrow"}); return; }

    // NumLock OFF のテンキーは入力用途と衝突するため対象外
    if(typeof e.code==="string" && e.code.startsWith("Numpad")){ dbgKey("shift-exit", e, {reason:"numpad"}); return; }

    // activeCell が未設定の場合、フォーカス要素から推測（contenteditable対策）
    if(!activeCell){
      const td = document.activeElement?.closest?.("td");
      if(td){ activeCell = td; td.classList.add('cell-selected'); }
    }
    if(!activeCell){ dbgKey("shift-exit", e, {reason:"no-activeCell"}); return; }

    const activeTd = (activeCell.tagName==="TD") ? activeCell : activeCell.closest?.("td");
    if(!activeTd){ dbgKey("shift-exit", e, {reason:"active-not-td"}); return; }

    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    dbgKey("shift-stop", e, null);

    if(!shiftAnchorCell) shiftAnchorCell = activeTd;

    const baseTd = (shiftAnchorCell.tagName==="TD") ? shiftAnchorCell : shiftAnchorCell.closest?.("td");
    const rowType = baseTd.dataset.rowType;
    const maxDay = getVisibleMaxDay();

    const rowList = getRowIndexList(rowType);
    const curRow = parseInt(activeTd.dataset.rowIndex,10);
    const curDay = parseInt(activeTd.dataset.day,10);

    let r = curRow;
    let d = curDay;

    if(e.key==="ArrowLeft")  d = Math.max(1, d-1);
    if(e.key==="ArrowRight") d = Math.min(maxDay, d+1);

    if(e.key==="ArrowUp"||e.key==="ArrowDown"){
      const idx = rowList.indexOf(curRow);
      if(idx !== -1){
        const nextIdx = e.key==="ArrowUp" ? Math.max(0, idx-1) : Math.min(rowList.length-1, idx+1);
        r = rowList[nextIdx];
      }else{
        r = rowList[0];
      }
    }

    const next = getCellByRowDay(rowType, r, d);
    dbgKey("shift-move", e, {rowType, curRow, curDay, nextRow:r, nextDay:d, nextFound:!!next, rowListLen:rowList.length, maxDay});
    if(!next){ dbgKey("shift-exit", e, {reason:"next-null"}); return; }

    const rectKeys = buildRectKeys(baseTd, next);
    dbgKey("shift-rect", e, {rectSize: rectKeys.size, anchor: cellKey(baseTd), next: cellKey(next)});

    suppressShiftAnchorReset=true;
    pointerDown = false;
    applySelectionKeys(rectKeys, next);
    try{ next.focus({preventScroll:true}); }catch(_){ try{ next.focus(); }catch(__){} }

        suppressShiftAnchorReset=false;
dbgKey("shift-done", e, null);
  }, true);
renderKeypad();

  // ドラッグ範囲選択中にセル内テキストが選択されるのを防止
  document.addEventListener("selectstart", (e)=>{
    if(dragSelecting){ e.preventDefault(); }
  });

  // 範囲選択：安定版（mouse主体）。段ずれは開始段へスナップ。表外クリックで状態リセット。
  const resolveCellAtPoint = (x,y)=>{
    const table = document.getElementById("scheduleTable");
    if(!table) return null;
    const els = (document.elementsFromPoint ? document.elementsFromPoint(x, y) : []);
    for(const el of els){
      const td = el && el.closest ? el.closest('td[data-day][data-row-type][data-emp-id]') : null;
      if(td && table.contains(td)) return td;
    }
    const el = document.elementFromPoint(x, y);
    const td = el && el.closest ? el.closest('td[data-day][data-row-type][data-emp-id]') : null;
    return (td && table.contains(td)) ? td : null;
  };

  const startDragOnCell = (td, e, typeTag)=>{
    if(!td) return;
    if(td.dataset.rowType==="support") return;

    // 2段目(note)は複数セル選択/範囲選択を禁止：単一セル選択のみ
    if(td.dataset.rowType==="note"){
      try{ e.preventDefault(); }catch(_){}
      // クリック=単一選択。Ctrlでも加算/除外しない
      dragAdditive = false;
      lastMouseDownAdditive = false;
      ctrlTogglePending = false;
      ctrlPendingCell = null;
      dragRangeMode = "replace";
      dragRangeModeStart = "replace";
      dragBaseSelectionKeys = null;
      clearDragPreview();
      setActiveCell(td,false);
      logDragEvent({t:Date.now(),type:typeTag+"(note-single)",button:e.button,buttons:e.buttons,ctrl:!!(e.ctrlKey||e.metaKey),meta:!!e.metaKey,target:e.target?.tagName,td:{rt:td.dataset.rowType,emp:td.dataset.empId,day:td.dataset.day}});
      return;
    }


    dragAdditive = !!(e.ctrlKey || e.metaKey || ctrlDown);
    lastMouseDownAdditive = dragAdditive;

    // Ctrlドラッグのモード：開始セルが選択済みなら除外(remove)、未選択なら追加(add)
    const k = cellKey(td);
    dragRangeMode = dragAdditive ? (selectedKeySet.has(k) ? "remove" : "add") : "replace";
    dragRangeModeStart = dragRangeMode;

    // Ctrlドラッグでは、開始時点の選択をスナップショットとして保持（ドラッグ中のプレビュー用）
    dragBaseSelectionKeys = dragAdditive ? new Set(selectedKeySet) : null;

    pointerDown=true;
    didDrag=false;
    dragSelecting=false;
    dragStartCell=td;
    dragStartX=e.clientX; dragStartY=e.clientY;
    dragMoveCount=0;
    dragLastHit=null;

    try{ e.preventDefault(); }catch(_){}

    // Ctrl/Metaの場合はクリックかドラッグかを mouseup まで保留
    ctrlTogglePending = dragAdditive;
    ctrlPendingCell = dragAdditive ? td : null;

    // ctrl click preview (確定は mouseup)
    if(dragAdditive && dragRangeMode==='remove'){
      clearDragPreview();

    shiftAnchorCell=null;
      td.classList.add('cell-preview-remove');
      setDragHint('remove', 1);
    }else if(dragAdditive && dragRangeMode==='add'){
      clearDragPreview();
      // 追加候補は未選択セルのみ
      if(!selectedKeySet.has(cellKey(td))) td.classList.add('cell-preview-add');
      setDragHint('add', selectedKeySet.has(cellKey(td)) ? 0 : 1);
    }

    if(dragAdditive){
      // Ctrl操作では selection の増減は mouseup/drag確定時に行う。activeは維持。
      // ただし段違いのドラッグ開始を防ぐため、選択がある場合は段を合わせる
      if(selectedCells.length>0){
        const baseType = selectedCells[0].dataset.rowType;
        if(td.dataset.rowType !== baseType) return;
      }
    }else{
      // 通常クリックはアクティブを更新し、選択を置換
      setActiveCell(td,false);
    }

    logDragEvent({t:Date.now(),type:typeTag,button:e.button,buttons:e.buttons,ctrl:e.ctrlKey,meta:e.metaKey,target:e.target?.tagName,td:{rt:td.dataset.rowType,emp:td.dataset.empId,day:td.dataset.day}});
  };

  const handleDragMove = (e, typeTag)=>{
    // Ctrl/Metaを押しながらドラッグ中は既存選択に追加
    dragAdditive = dragAdditive || !!(e.ctrlKey || e.metaKey || ctrlDown);
    if(dragAdditive && ctrlTogglePending && dragStartCell){
      // 開始セルから動いた時点で「ドラッグ」とみなしてトグル保留を解除
      // （クリックなら mouseup でトグルする）
      const tdNow = resolveCellAtPoint(e.clientX, e.clientY);
      if(tdNow && tdNow!==dragStartCell){ ctrlTogglePending=false; ctrlPendingCell=null; }
    }
    // Ctrl/Metaを押しながらドラッグ中は既存選択に追加
    dragAdditive = dragAdditive || !!(e.ctrlKey || e.metaKey || ctrlDown);
    if(!pointerDown || !dragStartCell) return;
    dragAdditive = dragAdditive || !!(e.ctrlKey || e.metaKey || ctrlDown);
    // moveログ
    logDragEvent({t:Date.now(),type:`${typeTag}(move)`,buttons:e.buttons,ctrl:e.ctrlKey,meta:e.metaKey,target:e.target?.tagName});
    // moveログ（Ctrlドラッグが無視されていないか確認するため常に出す）
    logDragEvent({t:Date.now(),type:`${typeTag}(move)`,buttons:e.buttons,ctrl:e.ctrlKey,meta:e.metaKey,target:e.target?.tagName});

    const table = document.getElementById("scheduleTable");
    if(!table) return;

    let td = resolveCellAtPoint(e.clientX, e.clientY);
    if(!td){
      logDragEvent({t:Date.now(),type:`${typeTag}(no-td)`,buttons:e.buttons,target:e.target?.tagName});
      return;
    }
    if(td.dataset.rowType==="support") return;

    const startType = dragStartCell.dataset.rowType;
    const hitType = td.dataset.rowType;

    if(hitType !== startType){
      const empId = td.dataset.empId;
      const day = td.dataset.day;
      const snapped = table.querySelector(`td[data-row-type="${startType}"][data-emp-id="${CSS.escape(empId)}"][data-day="${CSS.escape(day)}"]`);
      if(snapped) td = snapped;
      else return;
    }

    dragMoveCount++;
    dragLastHit = { rowType: td.dataset.rowType, empId: td.dataset.empId||null, day: td.dataset.day||null };

    // セル境界を跨がなくても、一定距離動いたらドラッグとして扱う（Ctrl除外/追加の安定化）
    const movedPx = Math.abs(e.clientX - dragStartX) + Math.abs(e.clientY - dragStartY);
    if(!didDrag && td === dragStartCell && movedPx < 6) return;

    if(!didDrag){
      didDrag=true;
      dragSelecting=true;
      if(dom.scheduleInner) dom.scheduleInner.classList.add("drag-selecting");
    }

    updateDragSelection(td);
    if(dragAdditive && dragStartCell){ activeCell = dragStartCell; }
    logDragEvent({t:Date.now(),type:typeTag,buttons:e.buttons,ctrl:e.ctrlKey,meta:e.metaKey,target:e.target?.tagName,td:{rt:td.dataset.rowType,emp:td.dataset.empId,day:td.dataset.day}});
  };

  const endDrag = (e, typeTag)=>{
    // drag/click終了時はプレビューを必ず消す
    // （確定後の描画は選択クラスで表現）
    
    if(!pointerDown) return;

    const wasDragging = dragSelecting || didDrag;
    const movedPx = e ? (Math.abs((e.clientX||0) - dragStartX) + Math.abs((e.clientY||0) - dragStartY)) : 0;

    // Ctrlクリック（ドラッグ無し）: トグルで除外/追加（微小移動はクリック扱い）
    if(dragAdditive && ctrlPendingCell && (!wasDragging || movedPx < 6)){
      toggleCellInSelection(ctrlPendingCell);
      clearDragPreview();
    }

    // Ctrlドラッグ（確定）: プレビューを確定して適用
    if(dragAdditive && wasDragging && dragBaseSelectionKeys && dragLastRectKeys){
      const base = dragBaseSelectionKeys;
      const rect = dragLastRectKeys;

      let committed = new Set(base);

      if(dragRangeMode === "add"){
        rect.forEach(k=>committed.add(k));
      }else if(dragRangeMode === "remove"){
        rect.forEach(k=>{ if(base.has(k)) committed.delete(k); });
      }

      if(committed.size===0){
        committed.add(cellKey(dragStartCell));
      }
      applySelectionKeys(committed, dragStartCell);
      clearDragPreview();
    }

        clearDragPreview();

        if(activeCell){ try{ activeCell.focus({preventScroll:true}); }catch(_){ try{ activeCell.focus(); }catch(__){} } }

    pointerDown=false;
    didDrag=false;
    dragSelecting=false;
    dragStartCell=null;
    dragBaseSelectionKeys=null;
    dragLastRectKeys=null;
    ctrlTogglePending=false;
    ctrlPendingCell=null;
    dragAdditive=false;

    if(dom.scheduleInner) dom.scheduleInner.classList.remove("drag-selecting");
    if(wasDragging){
      dragJustEnded=true;
      setTimeout(()=>{ dragJustEnded=false; }, 0);
    }
    logDragEvent({t:Date.now(),type:typeTag,button:e?.button,buttons:e?.buttons,ctrl:e?.ctrlKey,meta:e?.metaKey,target:e?.target?.tagName});
  };

  // 表外クリックで強制リセット（再現していた「外を押すと復帰」を自動化）
  document.addEventListener("mousedown",(e)=>{
    const table = document.getElementById("scheduleTable");
    if(table && !table.contains(e.target)){
      endDrag(e, "md(out)");
    }
  }, true);

  // 開始（セル上）
  document.addEventListener("mousedown",(e)=>{
    if(e.button!==0) return;
    const td = resolveCellAtPoint(e.clientX, e.clientY);
    if(!td) return;
    startDragOnCell(td, e, "md");
  }, true);

  // 移動・終了
  document.addEventListener("mousemove",(e)=>{ handleDragMove(e, "mm"); }, true);
  document.addEventListener("mouseup",(e)=>{ endDrag(e, "mu"); }, true);



  document.addEventListener("selectstart", (e)=>{
    if(dragSelecting){
      e.preventDefault();
    }
  });
}


function getInputMode(){ return ctrlDown ? "leave" : "work"; }

// テンキー/数字キー入力を安定して拾う（NumLock OFF のナビゲーションキーも対応）
function normalizeDigitKey(e){
  if(!e) return null;
  if(typeof e.key === "string" && /^\d$/.test(e.key)) return e.key;
  if(typeof e.code === "string"){
    const m = e.code.match(/^Numpad(\d)$/);
    if(m) return m[1];
  }
  // NumLock OFF の場合、テンキーがナビゲーションキーとして送られることがある
  // ※通常の十字キー（ArrowUpなど）まで数字扱いにするとセル移動と衝突するため、
  //   codeがNumpad系のときだけ数字へ正規化する
  const map = {
    Home:"7", ArrowUp:"8", PageUp:"9",
    ArrowLeft:"4", Clear:"5", ArrowRight:"6",
    End:"1", ArrowDown:"2", PageDown:"3",
    Insert:"0"
  };
  if(typeof e.code === "string" && e.code.startsWith("Numpad") && map[e.key]) return map[e.key];
  return null;
}
// WS_GLOBAL_DIGIT_INPUT: 数字/テンキー(1-9)でコード入力（2段目(note)では通常入力を優先）
document.addEventListener("keydown",(e)=>{
  const digit = normalizeDigitKey(e);
  if(!digit) return;
  // 押しっぱなし連打は無視
  if(e.repeat) return;
  // IME合成中は無視
  if(e.isComposing || e.key==="Process") return;

  // 入力フォームや設定ダイアログ中は無視
  const t = e.target;
  if(t && (t.tagName==="INPUT"||t.tagName==="TEXTAREA"||t.tagName==="SELECT")) return;

  // アクティブセルが main のときだけコード入力として扱う（note は自由入力を優先）
  if(!activeCell) return;
  const td = (activeCell.tagName==="TD") ? activeCell : activeCell.closest?.("td");
  if(!td) return;
  if(td.dataset.rowType!=="main") return;

  // Ctrl+数字 のブラウザ既定(タブ切替等)を抑止
  try{ e.preventDefault(); }catch(_){}
  try{ e.stopPropagation(); }catch(_){}
  try{ e.stopImmediatePropagation(); }catch(_){}

  dbgKey("digit-enter", e, {digit});
  try{
    handleNumericInput(Number(digit));
    dbgKey("digit-apply", e, {digit});
  }catch(err){
    dbgKey("digit-error", e, {digit, msg:String(err)});
  }
}, true);



/* ===== Modals ===== */
let settingsAfterSaveCallback=null;
let settingsScope="auto"; // auto: 開いている年月が作成済みなら current、未作成なら template
let settingsTempStoreId = -1; // 設定モーダル内で未保存の新規店舗に付与する仮ID（負数）
function initModals(){
  dom.settingsCloseButton.addEventListener("click", closeSettingsModal);
  dom.settingsCancelButton.addEventListener("click", closeSettingsModal);
  dom.settingsSaveButton.addEventListener("click", ()=>{
    saveSettingsFromUI();
    persistState();
    refreshAfterMasterChange();
    closeSettingsModal();
    if(settingsAfterSaveCallback){ const cb=settingsAfterSaveCallback; settingsAfterSaveCallback=null; cb(); }
  });


  document.querySelectorAll(".modal-tab").forEach(tab=>{
    tab.addEventListener("click", ()=>switchSettingsTab(tab));
  });

  dom.addStoreButton.addEventListener("click", ()=>addStoreRow());
  dom.addEmployeeButton.addEventListener("click", ()=>addEmployeeRow());
  dom.addLeaveCodeButton.addEventListener("click", ()=>addLeaveCodeRow());

  dom.unsavedDiscardButton.addEventListener("click", ()=>{
    closeUnsavedModal();
    const target=pendingNavigationTarget;
    pendingNavigationTarget=null;
    if(target){
      dirty=false;
      updateSaveButton();
      performNavigation(target.storeId, target.yearMonth);
    }
  });
  dom.unsavedSaveButton.addEventListener("click", ()=>{
    persistState();
    dirty=false;
    updateSaveButton();
    closeUnsavedModal();
    const target=pendingNavigationTarget;
    pendingNavigationTarget=null;
    if(target) performNavigation(target.storeId, target.yearMonth);
  });
  dom.unsavedCancelButton.addEventListener("click", ()=>{
    closeUnsavedModal();
    pendingNavigationTarget=null;
  });

  dom.newScheduleWithSettingsButton.addEventListener("click", ()=>{
    closeNewScheduleModal();
    openSettingsModal(()=>{ createScheduleForCurrentYearMonth(); renderAll(); }, "template");
  });
  dom.newScheduleDirectButton.addEventListener("click", ()=>{
    closeNewScheduleModal();
    createScheduleForCurrentYearMonth();
    renderAll();
  });
  dom.newScheduleCancelButton.addEventListener("click", ()=>{
    closeNewScheduleModal();
    if(appState.settings.lastYearMonth){
      dom.monthInput.value=appState.settings.lastYearMonth;
      currentYearMonth=appState.settings.lastYearMonth;
    }
  });
}

/* ===== Debug Tools ===== */
let debugVisible=false;
function initDebugTools(){
  if(dom.debugButton){
    dom.debugButton.addEventListener("click", toggleDebugPanel);
  }
  document.addEventListener("keydown",(e)=>{
    if(e.ctrlKey && e.shiftKey && (e.key==="D" || e.key==="d")){
      e.preventDefault();
      toggleDebugPanel();
    }
  });

  if(dom.dbgExport) dom.dbgExport.addEventListener("click", exportAllData);
  if(dom.dbgCopyState) dom.dbgCopyState.addEventListener("click", copyDebugState);
  if(dom.dbgFixSnapshot) dom.dbgFixSnapshot.addEventListener("click", ()=>{
    fixCurrentMonthSnapshotFromTemplate();
    renderAll();
    alert("この年月の入力ルール（スナップショット）を最新マスタで更新しました。");
  });
  if(dom.dbgReset) dom.dbgReset.addEventListener("click", ()=>{
    if(!confirm("全データを初期化します。元に戻せません。よろしいですか？")) return;
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  });

  // 状態参照用
  window.__WS_DEBUG__ = {
    getState: ()=>getDebugState(),
    fixSnapshot: ()=>{ fixCurrentMonthSnapshotFromTemplate(); renderAll(); },
    export: ()=>exportAllData(),
    reset: ()=>{ localStorage.removeItem(STORAGE_KEY); location.reload(); }
  };

  setInterval(()=>{ if(debugVisible) renderDebugInfo(); }, 200);
}

function toggleDebugPanel(){
  debugVisible=!debugVisible;
  if(dom.debugSection) dom.debugSection.style.display = debugVisible ? "block" : "none";
  if(debugVisible) renderDebugInfo();
}

function getDebugState(){
  const schedule=getCurrentSchedule();
  const snap = schedule?.masterSnapshot || null;
  const active = activeCell ? {
    rowType: activeCell.dataset.rowType,
    empId: activeCell.dataset.empId,
    day: activeCell.dataset.day,
    text: (activeCell.textContent||"").trim(),
    readonly: isCellReadonly(activeCell)
  } : null;

  let mappingCount=0;
  try{
    const mode=getInputMode();
    const workContextStoreId=getWorkContextStoreId();
    const master = snap || appState.templateMaster;
    const mapping={};
    if(mode==="work"){
      master.workCodes.forEach(w=>{
        if(!w.key) return;
        if(isSupportMode && !(w.code==="E"||w.code==="F")) return;
        const store=master.stores.find(s=>s.id===workContextStoreId);
        if(!store) return;
        const sc=(store.storeCodes||[]).find(x=>x.code===w.code);
        if(!sc || sc.type==="disabled") return;
        mapping[w.key]=w.code;
      });
    }else{
      master.leaveCodes.forEach(l=>{
        if(!l.key) return;
        mapping[l.key]=l.code;
      });
    }
    mappingCount=Object.keys(mapping).length;
  }catch(_){}

  const store = (schedule?.masterSnapshot?.stores||[]).find(s=>s.id===currentStoreId) || appState.templateMaster.stores.find(s=>s.id===currentStoreId) || null;
  const ctxStoreId = getWorkContextStoreId();
  const ctxStore = (snap?.stores||[]).find(s=>s.id===ctxStoreId) || appState.templateMaster.stores.find(s=>s.id===ctxStoreId) || null;

  return {
    yearMonth: currentYearMonth,
    currentStoreId,
    currentStoreName: store?.name || null,
    supportMode: isSupportMode,
    ctrlDown,
    inputMode: getInputMode(),
    workContextStoreId: ctxStoreId,
    workContextStoreName: ctxStore?.name || null,
    hasSchedule: !!schedule,
    mappingCount,
    selectedCount: selectedCells.length,
    drag: {
      pointerDown,
      didDrag,
      dragSelecting,
      dragJustEnded,
      additive: dragAdditive,
      rangeMode: dragRangeMode,
      rangeModeStart: dragRangeModeStart,
      previewRect: dragLastRectKeys ? dragLastRectKeys.size : 0,
      moveCount: dragMoveCount,
      start: dragStartCell ? {
        rowType: dragStartCell.dataset.rowType,
        empId: dragStartCell.dataset.empId,
        day: dragStartCell.dataset.day
      } : null,
      lastHit: dragLastHit,
      recentEvents: dragEventLog.slice(-30)
    },
    activeCell: active,
    keyDebugCount: (window.__KEY_DEBUG__?.events||[]).length,
    keyDebugLast: (window.__KEY_DEBUG__?.events||[]).slice(-12)
  };
}

function renderDebugInfo(){
  if(!dom.debugInfo) return;
  const st=getDebugState();
  dom.debugInfo.innerHTML = `
    <div><strong>年月</strong>：${escapeHtml(st.yearMonth||"")}</div>
    <div><strong>店舗</strong>：${escapeHtml(String(st.currentStoreId||""))} / ${escapeHtml(st.currentStoreName||"")}</div>
    <div><strong>入力モード</strong>：${escapeHtml(st.inputMode)}（Ctrl=${st.ctrlDown}） / 応援=${st.supportMode}</div>
    <div><strong>有効キー数</strong>：${st.mappingCount}（0だと入力できません）</div>
    <div><strong>選択セル数</strong>：${st.selectedCount}</div>
    <div><strong>ドラッグ状態</strong>：pointerDown=${pointerDown} / didDrag=${didDrag} / dragSelecting=${dragSelecting} / dragJustEnded=${dragJustEnded}</div>
    <div><strong>ドラッグ計測</strong>：moveCount=${dragMoveCount} / start=${dragStartCell ? `${dragStartCell.dataset.rowType||"-"} emp=${dragStartCell.dataset.empId||"-"} day=${dragStartCell.dataset.day||"-"} idx=${dragStartCell.dataset.rowIndex||"-"}` : "(なし)"} / lastHit=${dragLastHit ? `${dragLastHit.rowType} emp=${dragLastHit.empId||"-"} day=${dragLastHit.day||"-"}` : "(なし)"}</div>
    <div><strong>アクティブセル</strong>：${st.activeCell ? `${escapeHtml(st.activeCell.rowType)} emp=${escapeHtml(st.activeCell.empId)} day=${escapeHtml(st.activeCell.day)} text="${escapeHtml(st.activeCell.text)}" readonly=${st.activeCell.readonly}` : "(なし)"}</div>
    <div class="divider"></div>
    <div class="text-muted">Consoleで <code>__WS_DEBUG__.getState()</code> を実行すると同じ情報がJSONで取得できます。</div>
<div class="divider"></div>
<div style="font-weight:800;margin-bottom:6px;">ドラッグイベントログ（最新）</div>
<div id="debugDragLog" style="font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace; font-size:10px; white-space:pre-wrap; color:var(--text-muted);"></div>
  `;
  if(dom.debugDragLog){
    const lines = dragEventLog.map(ev=>{
      const t = new Date(ev.t||Date.now()).toLocaleTimeString();
      const td = ev.td ? ` td(${ev.td.rt||""} emp=${ev.td.emp||""} day=${ev.td.day||""})` : "";
      return `${t} ${ev.type||""} btn=${ev.button??""} buttons=${ev.buttons??""} target=${ev.target||""}${td}
    <div style="margin-top:10px;padding-top:8px;border-top:1px solid #e5e7eb;">
      <strong>KEY_DEBUG (last 12)</strong>
      <pre style="white-space:pre-wrap;font-size:11px;line-height:1.35;margin:6px 0 0 0;background:#f8fafc;border:1px solid #e5e7eb;border-radius:8px;padding:8px;max-height:180px;overflow:auto;">${escapeHtml((window.__KEY_DEBUG__?.events||[]).slice(-12).map(ev=>{
        const dt=new Date(ev.t); const time=dt.toLocaleTimeString();
        const extra=ev.extra?JSON.stringify(ev.extra):"";
        return `${time} [${ev.stage}] key=${ev.key} code=${ev.code} shift=${ev.shift} ctrl=${ev.ctrl} composing=${ev.composing} prevented=${ev.defaultPrevented} target=${ev.target} activeEl=${ev.activeEl} activeCell=${ev.activeCell} anchor=${ev.anchor} ${extra}`;
      }).join("\n"))}</pre>
    </div>
`;
    });
    dom.debugDragLog.textContent = lines.slice(-12).join("\n");
  }
}

function exportAllData(){
  const data=localStorage.getItem(STORAGE_KEY) || "";
  const blob=new Blob([data], {type:"application/json"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;
  a.download=`workSchedule_backup_${(currentYearMonth||"data")}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function copyDebugState(){
  try{
    const st=getDebugState();
    await navigator.clipboard.writeText(JSON.stringify(st,null,2));
    alert("状態をクリップボードにコピーしました。");
  }catch(e){
    console.warn(e);
    alert("コピーに失敗しました（クリップボード権限が必要）。Consoleで __WS_DEBUG__.getState() を実行してください。");
  }
}

// “この年月のスナップショット”が古くて業務コードが無効のまま → 入力できないケースを救済
function fixCurrentMonthSnapshotFromTemplate(){
  const schedule=getCurrentSchedule();
  if(!schedule) return;
  const t=appState.templateMaster;

  // 店舗情報（storeCodes含む）をテンプレからコピーして、この年月だけ更新
  schedule.masterSnapshot.stores = deepClone(t.stores);
  schedule.masterSnapshot.workCodes = deepClone(t.workCodes);
  schedule.masterSnapshot.leaveCodes = deepClone(t.leaveCodes);

  // 既存の勤務表データは保持（byStore / assignmentsは触らない）
  persistState();
}


function openSettingsModal(afterSaveCb){
  settingsAfterSaveCallback = afterSaveCb || null;
  const schedule = getCurrentSchedule();
  settingsScope = schedule ? "current" : "template";
  // スコープ表示（簡易メモ）
  const noteEl = document.getElementById("settingsScopeNote");
  if(noteEl){
    noteEl.textContent = schedule
      ? "現在開いている年月のマスタ（この勤務表だけに反映）を編集します。"
      : "未作成の年月のため、今後の新規作成用マスタを編集します。";
  }

  // 「この変更を新規作成時にも反映」：既存の最新勤務表を開いている時のみ表示（デフォルトON）
  const propagateWrap=document.getElementById("propagateToTemplateWrap");
  const propagateCb=document.getElementById("propagateToTemplateCheckbox");
  const canPropagate=!!schedule && isCurrentYearMonthLatest();
  if(propagateWrap){
    propagateWrap.style.display = canPropagate ? "block" : "none";
  }
  if(propagateCb){
    propagateCb.checked = true;
    propagateCb.disabled = !canPropagate;
  }
  populateSettingsFromState();
  dom.settingsModalBackdrop.classList.add("visible");
}
function closeSettingsModal(){ dom.settingsModalBackdrop.classList.remove("visible"); }
function switchSettingsTab(tabElem){
  document.querySelectorAll(".modal-tab").forEach(t=>t.classList.remove("active"));
  tabElem.classList.add("active");
  const targetId=tabElem.dataset.target;
  document.querySelectorAll(".settings-panel").forEach(p=>p.classList.remove("active"));
  document.getElementById(targetId).classList.add("active");

  if(targetId==="settingsEmployees"){
    refreshEmployeeStoreOptionsFromSettings();
    // 従業員タブを開いたタイミングで右側（店舗別リスト）を必ず再描画し、
    // DnDのwireも確実に初期化する。
    try{ refreshEmployeeOrderPanel(); }catch(_e){}
  }
}
function openUnsavedModal(){ dom.unsavedModalBackdrop.classList.add("visible"); }
function closeUnsavedModal(){ dom.unsavedModalBackdrop.classList.remove("visible"); }

function showNewScheduleModal(){
  const [year,month]=currentYearMonth.split("-").map(v=>parseInt(v,10));
  dom.newScheduleMessage.textContent = `${year}年${month}月の勤務表が存在しません。新規作成します。`;
  dom.newScheduleModalBackdrop.classList.add("visible");
}
function closeNewScheduleModal(){ dom.newScheduleModalBackdrop.classList.remove("visible"); }

/* ===== Initial Context ===== */
function loadInitialContext(){
  const now=new Date();
  const ymNow = `${now.getFullYear().toString().padStart(4,"0")}-${(now.getMonth()+1).toString().padStart(2,"0")}`;
  currentYearMonth = appState.settings.lastYearMonth || ymNow;
  dom.monthInput.value=currentYearMonth;

  const stores=appState.templateMaster.stores;
  if(stores.length>0){
    currentStoreId = appState.settings.lastStoreId || stores.slice().sort((a,b)=>(a.order||0)-(b.order||0))[0].id;
  }else{
    currentStoreId=null;
  }
  updateAutoSaveToggleUI();
}

/* ===== Navigation ===== */
function navigateTo(targetStoreId, targetYearMonth){
  if(!targetYearMonth) return;
  const target={storeId:targetStoreId, yearMonth:targetYearMonth};
  if(!appState.settings.autoSave && dirty){
    pendingNavigationTarget=target;
    openUnsavedModal();
    return;
  }
  performNavigation(targetStoreId, targetYearMonth);
}

function performNavigation(targetStoreId, targetYearMonth){
  currentYearMonth=targetYearMonth;
  appState.settings.lastYearMonth=targetYearMonth;

  const stores=appState.templateMaster.stores;
  if(!targetStoreId && stores.length>0) currentStoreId=stores[0].id;
  else currentStoreId=targetStoreId;

  appState.settings.lastStoreId=currentStoreId;

  dirty=false;
  updateSaveButton();

  if(!appState.schedules[currentYearMonth]){
    showNewScheduleModal();
  }
  renderAll();
  persistState();
}

/* ===== Render ===== */
function renderAll(){
  renderStoreOptions();
  renderSupportStoreOptions();
  renderKeypad();
  renderSchedule();
}

function renderStoreOptions(){
  const schedule=getCurrentSchedule();
  const baseStores=(schedule? schedule.masterSnapshot.stores : appState.templateMaster.stores);
  const stores=baseStores.slice().sort((a,b)=>(a.order||0)-(b.order||0));
  dom.storeSelect.innerHTML="";
  if(stores.length===0){
    const opt=document.createElement("option");
    opt.value="";
    opt.textContent="（店舗なし：設定から追加）";
    dom.storeSelect.appendChild(opt);
    dom.storeSelect.disabled=true;
    currentStoreId=null;
    return;
  }
  dom.storeSelect.disabled=false;
  stores.forEach(store=>{
    const opt=document.createElement("option");
    opt.value=String(store.id);
    opt.textContent = store.name + (store.enabled ? "" : "（無効）");
    dom.storeSelect.appendChild(opt);
  });
  if(!currentStoreId || !stores.some(s=>s.id===currentStoreId)) currentStoreId=stores[0].id;
  dom.storeSelect.value=String(currentStoreId);
}

function renderSupportStoreOptions(){
  const schedule=getCurrentSchedule();
  const baseStores=(schedule? schedule.masterSnapshot.stores : appState.templateMaster.stores);
  const stores=baseStores.slice().sort((a,b)=>(a.order||0)-(b.order||0));
  const prev = dom.supportStoreSelect.value || "self";
  dom.supportStoreSelect.innerHTML="";
  const optSelf=document.createElement("option");
  optSelf.value="self";
  optSelf.textContent="自店舗（通常）";
  dom.supportStoreSelect.appendChild(optSelf);
  stores.forEach(store=>{
    const opt=document.createElement("option");
    opt.value=String(store.id);
    opt.textContent=store.name;
    dom.supportStoreSelect.appendChild(opt);
  });
  dom.supportStoreSelect.value = Array.from(dom.supportStoreSelect.options).some(o=>o.value===prev) ? prev : "self";
  isSupportMode = dom.supportStoreSelect.value !== "self";
}

function renderKeypad(){
  const mode=getInputMode();
  const master=appState.templateMaster;
  const workContextStoreId=getWorkContextStoreId();
  const mapping={};
  if(mode==="work"){
    master.workCodes.forEach(w=>{
      if(!w.key) return;
      if(isSupportMode && !(w.code==="E"||w.code==="F")) return;
      const store=master.stores.find(s=>s.id===workContextStoreId);
      if(!store) return;
      const sc=(store.storeCodes||[]).find(x=>x.code===w.code);
      if(!sc || sc.type==="disabled") return;
      mapping[w.key]={type:"work",code:w.code,shiftType:sc.type};
    });
  }else{
    master.leaveCodes.forEach(l=>{
      if(!l.key) return;
      mapping[l.key]={type:"leave",code:l.code};
    });
  }

  // 入力できない原因の大半は「この店舗で有効な業務コードが0件」または「セルが未選択」です。
  const availCount = Object.keys(mapping).length;
  if(getInputMode()==="work" && availCount===0){
    dom.keypad.innerHTML = "";
    const warn=document.createElement("div");
    warn.className="alert-item";
    warn.textContent="この店舗（または応援先）で有効な業務コードがありません。設定→店舗→業務コードを「日勤/夜勤」にしてください。";
    dom.alertList.innerHTML="";
    dom.alertList.appendChild(warn);
  }
  dom.keypad.innerHTML="";
  const layout=["7","8","9","4","5","6","1","2","3"];
  layout.forEach(num=>{
    const btn=document.createElement("button");
    const info=mapping[num];
    if(info){
      const spanCode=document.createElement("span");
      spanCode.className="code-label";
      spanCode.textContent=info.code;
      const spanNum=document.createElement("span");
      spanNum.textContent=`(${num})`;
      btn.appendChild(spanCode);
      btn.appendChild(spanNum);
      btn.addEventListener("click",()=>{
        if(!activeCell) return;
        if(activeCell.dataset.rowType!=="main") return;
        handleNumericInput(num);
      });
    }else{
      btn.textContent=num;
      btn.disabled=true;
    }
    dom.keypad.appendChild(btn);
  });

  if(mode==="leave"){
    dom.modeBadge.textContent="休暇コード（Ctrl）";
    dom.modeBadge.className="badge leave";
  }else{
    dom.modeBadge.textContent = isSupportMode ? "業務コード（応援）" : "業務コード";
    dom.modeBadge.className="badge "+(isSupportMode?"support":"work");
  }
}

function renderSchedule(){
  if(!dragAdditive && !preserveSelectionOnRender){ clearSelection(); }
  dom.scheduleInner.innerHTML="";
  const stores=appState.templateMaster.stores;
  if(!currentYearMonth || stores.length===0 || !currentStoreId){
    dom.scheduleInner.appendChild(dom.schedulePlaceholder);
    dom.schedulePlaceholder.style.display="block";
    dom.scheduleTitle.textContent="";
    return;
  }

  const schedule=appState.schedules[currentYearMonth];
  if(!schedule){
    dom.scheduleInner.appendChild(dom.schedulePlaceholder);
    dom.schedulePlaceholder.style.display="block";
    const y=parseInt(currentYearMonth.slice(0,4),10);
    const m=parseInt(currentYearMonth.slice(5,7),10);
    const wk=toWareki(y,m);
    dom.scheduleTitle.textContent=`勤務予定表　　${wk.gengo}${wk.yearStr}年 ${m}月分（未作成）`;
    return;
  }

  dom.schedulePlaceholder.style.display="none";
  currentSchedule=schedule;

  const storeSnapshot=schedule.masterSnapshot.stores.find(s=>s.id===currentStoreId);
  if(!storeSnapshot){
    dom.scheduleInner.appendChild(dom.schedulePlaceholder);
    dom.schedulePlaceholder.style.display="block";
    dom.schedulePlaceholder.textContent="この年月の勤務表には、選択された店舗が含まれていません。";
    dom.scheduleTitle.textContent="";
    return;
  }

  const wk=toWareki(schedule.year, schedule.month);
  dom.scheduleTitle.textContent=`${storeSnapshot.name}　勤務予定表　　${wk.gengo}${wk.yearStr}年　${schedule.month}月分`;

  currentStoreSchedule=schedule.byStore[currentStoreId];
  const table=buildScheduleTable(schedule, currentStoreId);
  dom.scheduleInner.appendChild(table);

  validateNightShiftsForCurrent();

  if(pendingFocus){
    const {empId,rowType,day}=pendingFocus;
    pendingFocus=null;
    const tgt=table.querySelector(`td[data-row-type="${rowType}"][data-emp-id="${empId}"][data-day="${day}"]`);
    if(tgt){ tgt.focus(); setActiveCell(tgt,false); }
  }

  // 複数セル入力などで再描画しても選択を維持
  if(preserveSelectionOnRender){
    try{
      const keys = preserveSelectionKeys ? new Set(preserveSelectionKeys) : new Set();
      const prefer = preserveSelectionActiveKey ? getCellByKey(preserveSelectionActiveKey) : null;
      preserveSelectionOnRender=false;
      preserveSelectionKeys=null;
      preserveSelectionActiveKey=null;
      if(keys.size>0){
        applySelectionKeys(keys, prefer);
      }
    }catch(err){
      // fail-safe
      preserveSelectionOnRender=false;
      preserveSelectionKeys=null;
      preserveSelectionActiveKey=null;
    }
  }
}

/* ===== Table build ===== */
function buildScheduleTable(schedule, storeId){
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);
  const table=document.createElement("table");
  table.className="schedule";
  table.id="scheduleTable";
  const thead=document.createElement("thead");
  const tbody=document.createElement("tbody");

  const tr1=document.createElement("tr");
  const thCorner=document.createElement("th");
  thCorner.rowSpan=2;
  thCorner.className="col-employee-header namecol";
  thCorner.textContent="従業員";
  tr1.appendChild(thCorner);
  for(let d=1; d<=daysInMonth; d++){
    const th=document.createElement("th");
    th.textContent=d;
    tr1.appendChild(th);
  }
  thead.appendChild(tr1);

  const tr2=document.createElement("tr");
  tr2.className="weekday-row";
  const weekDays=["日","月","火","水","木","金","土"];
  for(let d=1; d<=daysInMonth; d++){
    const date=new Date(schedule.year, schedule.month-1, d);
    const w=date.getDay();
    const th=document.createElement("th");
    th.textContent=weekDays[w];
    if(w===0) th.classList.add("day-sun");
    if(w===6) th.classList.add("day-sat");
    tr2.appendChild(th);
  }
  thead.appendChild(tr2);

  const employees=getEmployeesInStore(schedule, storeId);
  const maxNameLen=employees.reduce((mx,e)=>Math.max(mx,(e.lastName+e.firstName).length),3);
  const nameColWidth=Math.min(160, Math.max(84, 10*maxNameLen+40));
  thCorner.style.minWidth=nameColWidth+"px";
  thCorner.style.maxWidth=nameColWidth+"px";

  let rowIndexCounter=0;

  employees.forEach(emp=>{
    const empId=emp.id;
    const formatted=formatEmployeeName(emp.lastName, emp.firstName);

    const mainRow=document.createElement("tr");
    mainRow.className="employee-main-row";
    const noteRow=document.createElement("tr");
    noteRow.className="employee-note-row";

    const nameTh=document.createElement("th");
    nameTh.rowSpan=2;
    nameTh.className="cell-emp-name";
    nameTh.style.minWidth=nameColWidth+"px";
    nameTh.style.maxWidth=nameColWidth+"px";
    nameTh.textContent=formatted;
    mainRow.appendChild(nameTh);

    for(let d=1; d<=daysInMonth; d++){
      const mainCell=document.createElement("td");
      const noteCell=document.createElement("td");
      mainCell.tabIndex=0; noteCell.tabIndex=0;

      mainCell.dataset.empId=String(empId);
      mainCell.dataset.day=String(d);
      mainCell.dataset.rowType="main";
      mainCell.dataset.rowIndex=String(rowIndexCounter);

      noteCell.dataset.empId=String(empId);
      noteCell.dataset.day=String(d);
      noteCell.dataset.rowType="note";
      noteCell.dataset.rowIndex=String(rowIndexCounter+1);

      const vMain=getAssignmentValue(schedule, storeId, empId, "main", d)||"";
      const vNote=getAssignmentValue(schedule, storeId, empId, "note", d)||"";

      renderCellValue(mainCell, vMain, schedule, storeId);
      renderCellValue(noteCell, vNote, schedule, storeId);

      attachCellEvents(mainCell);
      attachCellEvents(noteCell);

      mainRow.appendChild(mainCell);
      noteRow.appendChild(noteCell);
    }

    rowIndexCounter+=2;
    tbody.appendChild(mainRow);
    tbody.appendChild(noteRow);
  });

  const storeSnapshot=schedule.masterSnapshot.stores.find(s=>s.id===storeId);
  const usedCodes=(storeSnapshot.storeCodes||[]).filter(c=>c.type!=="disabled" && (c.code==="E"||c.code==="F"));
  usedCodes.forEach((sc,idx)=>{
    const code=sc.code;
    const label=code+"謹";
    const supportRow=document.createElement("tr");
    supportRow.className = (idx===0 ? "support-row support-first" : "support-row");
    const th=document.createElement("th");
    th.className="cell-support-header";
    th.style.minWidth=nameColWidth+"px";
    th.style.maxWidth=nameColWidth+"px";
    th.textContent=label;
    supportRow.appendChild(th);

    for(let d=1; d<=daysInMonth; d++){
      const cell=document.createElement("td");
      cell.dataset.rowType="support";
      cell.dataset.day=String(d);
      cell.classList.add("cell-readonly");
      const supporter=getSupporterFor(schedule, storeId, code, d);
      cell.textContent=supporter||"";
      supportRow.appendChild(cell);
    }
    tbody.appendChild(supportRow);
  });

  table.appendChild(thead);
  table.appendChild(tbody);
  return table;
}

/* ===== New schedule create ===== */
function createScheduleForCurrentYearMonth(){
  const [year,month]=currentYearMonth.split("-").map(v=>parseInt(v,10));
  const template=appState.templateMaster;
  const snapshot={
    stores:deepClone(template.stores),
    employees:deepClone(template.employees),
    workCodes:deepClone(template.workCodes),
    leaveCodes:deepClone(template.leaveCodes),
  };
  const schedule={ year,month, masterSnapshot:snapshot, byStore:{} };
  const daysInMonth=getDaysInMonth(year,month);

  snapshot.stores.filter(s=>s.enabled).forEach(store=>{
    const storeId=store.id;
    const empList=snapshot.employees.filter(e=>e.storeId===storeId);
    const assignments={};
    empList.forEach(emp=>{
      assignments[emp.id]={ main:new Array(daysInMonth).fill(""), note:new Array(daysInMonth).fill("") };
    });
    schedule.byStore[storeId]={assignments};
  });

  applyPendingCarryoversToSchedule(currentYearMonth, schedule);
  appState.schedules[currentYearMonth]=schedule;
  persistState();
}

function applyPendingCarryoversToSchedule(yearMonth, schedule){
  const pending=appState.pendingNightCarryovers?.[yearMonth];
  if(!pending) return;

  Object.keys(pending).forEach(storeIdStr=>{
    const storeId=Number(storeIdStr);
    const byStore=schedule.byStore[storeId];
    if(!byStore) return;
    const empMap=pending[storeIdStr];
    Object.keys(empMap).forEach(empIdStr=>{
      const empId=Number(empIdStr);
      const dayMap=empMap[empIdStr];
      const val=dayMap["1"];
      if(!val) return;
      if(!byStore.assignments[empId]) return;
      byStore.assignments[empId].main[0]=val;
    });
  });

  delete appState.pendingNightCarryovers[yearMonth];
}

/* ===== schedule data get/set ===== */
function getCurrentSchedule(){ return appState.schedules[currentYearMonth]||null; }

function getAssignmentValue(schedule, storeId, empId, rowType, day){
  const storeData=schedule.byStore[storeId];
  if(!storeData) return "";
  const empData=storeData.assignments[empId];
  if(!empData) return "";
  const arr = rowType==="main" ? empData.main : empData.note;
  return arr[day-1] || "";
}

function setAssignmentValue(schedule, storeId, empId, rowType, day, value){
  const storeData=schedule.byStore[storeId];
  if(!storeData) return;
  if(!storeData.assignments[empId]){
    storeData.assignments[empId]={main:[],note:[]};
  }
  const arr = rowType==="main" ? storeData.assignments[empId].main : storeData.assignments[empId].note;

  const prev = arr[day-1] || "";

  // ★重要：夜勤入り(ﾃ) / 夜勤明け(ﾋ) を編集・上書き・削除したときにペアが孤立しないよう自動で掃除する
  if(rowType==="main" && prev){
    const daysInMonth=getDaysInMonth(schedule.year, schedule.month);
    const newVal = value || "";

    // ﾃ を消した/上書きした → 翌日の ﾋ を消す（同月 or 翌月1日/保留）
    if(prev.includes("ﾃ") && !newVal.includes("ﾃ")){
      if(day < daysInMonth){
        const nextPrev = arr[day] || "";
        if(nextPrev && nextPrev.includes("ﾋ")){
          arr[day] = ""; // day+1
        }
      }else{
        const nextYm=nextMonthKey(currentYearMonth);
        const nextSchedule=appState.schedules[nextYm];
        if(nextSchedule && nextSchedule.byStore?.[storeId]?.assignments?.[empId]){
          const nextArr = nextSchedule.byStore[storeId].assignments[empId].main;
          const v = (nextArr?.[0]||"");
          if(v && v.includes("ﾋ")) nextArr[0] = "";
        }
        const p=appState.pendingNightCarryovers?.[nextYm]?.[storeId]?.[empId];
        if(p && p["1"]) delete p["1"];
      }
    }

    // ﾋ を消した/上書きした → 前日の ﾃ を消す（同月 or 前月末）
    if(prev.includes("ﾋ") && !newVal.includes("ﾋ")){
      if(day > 1){
        const prevPrev = arr[day-2] || "";
        if(prevPrev && prevPrev.includes("ﾃ")){
          arr[day-2] = ""; // day-1
        }
      }else{
        const prevYm=prevMonthKey(currentYearMonth);
        const prevSchedule=appState.schedules[prevYm];
        if(prevSchedule && prevSchedule.byStore?.[storeId]?.assignments?.[empId]){
          const prevDays=getDaysInMonth(prevSchedule.year, prevSchedule.month);
          const prevArr = prevSchedule.byStore[storeId].assignments[empId].main;
          const v = (prevArr?.[prevDays-1]||"");
          if(v && v.includes("ﾃ")) prevArr[prevDays-1] = "";
        }
      }
    }
  }

  arr[day-1] = value || "";
  markDirty();
}

function markDirty(){
  dirty=true;
  if(appState.settings.autoSave){
    persistState();
    dirty=false;
  }
  updateSaveButton();
}
function updateSaveButton(){ dom.saveButton.disabled = appState.settings.autoSave ? true : !dirty; }
function updateAutoSaveToggleUI(){
  if(appState.settings.autoSave) dom.autoSaveToggle.classList.add("on");
  else dom.autoSaveToggle.classList.remove("on");
}

/* ===== Cell events / selection ===== */
function attachCellEvents(cell){
  const rowType=cell.dataset.rowType;
  if(rowType==="support") return;

  cell.addEventListener("focus",()=>{
    if(dragSelecting) return;

    // Ctrl/Metaクリック直後は、mousedown側で選択処理を完結させる（focus側で選択を壊さない）
    if(lastMouseDownAdditive){
      // アクティブ枠だけ整える
      if(activeCell && activeCell!==cell){ activeCell.classList.remove('cell-selected'); }
      activeCell = cell;
      cell.classList.add('cell-selected');
      // 既に選択されていなければ追加（通常は既に追加済み）
      addCellToSelection(cell);
      lastMouseDownAdditive = false;
      return;
    }

    setActiveCell(cell, selectedCells.length>1);
  });

  cell.addEventListener("mousedown", (e)=>{ /* document側で処理 */ });

  cell.addEventListener("click",(e)=>{
    // ドラッグ範囲選択の直後に click が発火すると範囲選択が単一セルに潰れるため抑止
    if(dragJustEnded) return;
    // Ctrl/Metaクリックは document mousedown 側でトグル処理済み。ここで setActiveCell すると既存選択が消えるので何もしない
    if(e && (e.ctrlKey || e.metaKey || ctrlDown)) return;
    if(!dragSelecting) setActiveCell(cell,false);
  });

  cell.addEventListener("mouseover",()=>{ /* document mousemoveで処理 */ });
  cell.addEventListener("keydown",(e)=>handleCellKeyDown(e,cell));

  if(rowType==="note"){
    cell.contentEditable="true";
    cell.addEventListener("input",()=>{
      const schedule=getCurrentSchedule();
      if(!schedule) return;
      const empId=Number(cell.dataset.empId);
      const day=Number(cell.dataset.day);
      const val=(cell.textContent||"").trim();
      setAssignmentValue(schedule,currentStoreId,empId,"note",day,val);
    });
  }
}

function setActiveCell(cell, keepMulti){
  // Shift+矢印の範囲選択中はアンカーを維持（setActiveCellではリセットしない）
  if(!suppressShiftAnchorReset){ /* no-op */ }
  // クリック/移動でアクティブが変わったら Shift 範囲選択の起点をリセット

  if(!cell) return;
  if(!keepMulti){
    clearSelection();
  }else{
    // keepMultiのときは選択を維持し、段違いは無効
    if(selectedCells.length>0){
      const baseType = selectedCells[0].dataset.rowType;
      if(cell.dataset.rowType !== baseType) return;
    }
  }
  // 以前のアクティブ強調を解除
  if(activeCell && activeCell!==cell){ activeCell.classList.remove("cell-selected"); }
  activeCell = cell;
  addCellToSelection(cell);
  cell.classList.add("cell-selected");
  cell.classList.add("cell-multi");

  // キーボード移動の起点は「フォーカス」なので、常にアクティブへフォーカスを同期
  try{ cell.focus({preventScroll:true}); }catch(_){ try{ cell.focus(); }catch(__){} }

  renderDebugInfo && renderDebugInfo();
}


function clearSelection(){
  // 既存の選択表示を解除
  selectedCells.forEach(c=>c.classList.remove("cell-selected","cell-multi"));
  // 念のため残存する強調も解除
  document.querySelectorAll('#scheduleTable td.cell-selected, #scheduleTable td.cell-multi')
    .forEach(c=>c.classList.remove('cell-selected','cell-multi'));
  selectedCells=[];
  selectedKeySet=new Set();
  activeCell=null;
}

function cellKey(cell){
  return `${cell.dataset.rowType}|${cell.dataset.empId}|${cell.dataset.day}`;
}
function getCellByKey(key){
  const [rt, empId, day] = key.split("|");
  const table = document.getElementById("scheduleTable");
  if(!table) return null;
  return table.querySelector(`td[data-row-type="${rt}"][data-emp-id="${CSS.escape(empId)}"][data-day="${CSS.escape(day)}"]`);
}

function clearDragPreview(){
  const table = document.getElementById('scheduleTable');
  if(!table) return;
  table.querySelectorAll('td.cell-preview-add, td.cell-preview-remove')
    .forEach(c=>c.classList.remove('cell-preview-add','cell-preview-remove'));
  if(dom.dragHint){
    dom.dragHint.classList.add('hidden');
    dom.dragHint.classList.remove('add','remove');
    dom.dragHintText.textContent='';
    dom.dragHintPill.textContent='';
  }
}
function setDragHint(mode, count){
  if(!dom.dragHint) return;
  if(!mode || count<=0){
    dom.dragHint.classList.add('hidden');
    return;
  }
  dom.dragHint.classList.remove('hidden','add','remove');
  dom.dragHint.classList.add(mode);
  if(mode==='add'){
    dom.dragHintText.textContent = '追加選択のプレビュー';
    dom.dragHintPill.textContent = `+${count}`;
  }else if(mode==='remove'){
    dom.dragHintText.textContent = '選択解除のプレビュー';
    dom.dragHintPill.textContent = `-${count}`;
  }
}

function rebuildSelectedCellsFromKeys(){
  selectedCells = [];
  const table = document.getElementById("scheduleTable");
  if(!table) return;
  selectedKeySet.forEach(k=>{
    const c = getCellByKey(k);
    if(c){ selectedCells.push(c); c.classList.add("cell-multi"); }
  });
}
function applySelectionKeys(newKeys, activePrefer){
  const committing = !pointerDown; // mouseup等で確定反映する局面
  const table = document.getElementById('scheduleTable');

  if(committing && table){
    // 確定時は全セルから選択表示を完全に消してから再付与（取り残し防止）
    table.querySelectorAll('td.cell-selected, td.cell-multi').forEach(c=>{
      c.classList.remove('cell-selected','cell-multi');
    });
  }else{
    // ドラッグ中は最小限（ちらつき防止）
    selectedCells.forEach(c=>{
      c.classList.remove('cell-multi');
      if(!(activeCell && c===activeCell)) c.classList.remove('cell-selected');
    });
  }

  selectedKeySet = new Set(newKeys);

  // 再構築
  selectedCells = [];
  selectedKeySet.forEach(k=>{
    const c = getCellByKey(k);
    if(c){
      c.classList.add('cell-multi');
      selectedCells.push(c);
    }
  });

  // active の決定
  let nextActive = null;

  if(activePrefer){
    const kp = cellKey(activePrefer);
    if(selectedKeySet.has(kp)) nextActive = getCellByKey(kp);
  }
  if(!nextActive && activeCell){
    const ka = cellKey(activeCell);
    if(selectedKeySet.has(ka)) nextActive = getCellByKey(ka);
  }
  if(!nextActive){
    nextActive = selectedCells[selectedCells.length-1] || null;
  }

  if(activeCell && activeCell!==nextActive) activeCell.classList.remove('cell-selected');
  activeCell = nextActive;
  if(activeCell) activeCell.classList.add('cell-selected');

  // focus は endDrag 側で 1回だけ
}




function addCellToSelection(cell){
  const k = cellKey(cell);
  if(!selectedKeySet.has(k)){
    selectedKeySet.add(k);
    selectedCells.push(cell);
  }
  cell.classList.add("cell-multi");
}

function pickNextActiveAfterRemoval(removedKey){
  // できるだけ同じ従業員・同じ段で、日付が近いセルをアクティブにする
  const [rt, empId, dayStr] = removedKey.split("|");
  const removedDay = parseInt(dayStr,10);

  // 同じ行の候補を抽出
  const sameRow = Array.from(selectedKeySet).filter(k=>{
    const [rr, ee] = k.split("|");
    return rr===rt && ee===empId;
  }).map(k=>{
    const parts=k.split("|");
    return {k, day: parseInt(parts[2],10)};
  }).sort((a,b)=>a.day-b.day);

  if(sameRow.length){
    // removedDayより大きい最小、なければ小さい最大
    const right = sameRow.find(x=>x.day>removedDay);
    if(right) return right.k;
    return sameRow[sameRow.length-1].k;
  }

  // それ以外はキーをソートして最初のもの
  const all = Array.from(selectedKeySet).sort();
  return all[0] || null;
}

function toggleCellInSelection(cell){
  // 段違いは選択不可
  if(selectedCells.length>0){
    const baseType = selectedCells[0].dataset.rowType;
    if(cell.dataset.rowType !== baseType) return;
  }
  const k = cellKey(cell);
  const wasSelected = selectedKeySet.has(k);

  if(wasSelected){
    if(selectedKeySet.size===1){
      return; // 最後の1セルは解除しない
    }
    const removedActive = (activeCell && cellKey(activeCell)===k);
    selectedKeySet.delete(k);
    cell.classList.remove("cell-multi","cell-selected");

    if(removedActive){
      // 次のアクティブを決める（なるべく近いセル）
      const nextKey = pickNextActiveAfterRemoval(k);
      activeCell = nextKey ? getCellByKey(nextKey) : null;
    }
  }else{
    selectedKeySet.add(k);
    cell.classList.add("cell-multi");
    // 追加時はアクティブを動かさない（仕様）
  }

  // 表示と参照を同期
  rebuildSelectedCellsFromKeys();

  if(activeCell){
    activeCell.classList.add("cell-selected");
  }else{
    // 念のため：何か残っていれば最後をactive
    activeCell = selectedCells[selectedCells.length-1] || null;
    if(activeCell) activeCell.classList.add("cell-selected");
  }
}





function updateDragSelection(targetCell){
  if(!dragStartCell) return;
  const table = document.getElementById("scheduleTable");
  if(!table) return;

  const startRowType = dragStartCell.dataset.rowType;
  if(targetCell.dataset.rowType !== startRowType) return;

  const startIndex = parseInt(dragStartCell.dataset.rowIndex,10);
  const targetIndex = parseInt(targetCell.dataset.rowIndex,10);
  const startDay = parseInt(dragStartCell.dataset.day,10);
  const targetDay = parseInt(targetCell.dataset.day,10);

  const minRow = Math.min(startIndex, targetIndex);
  const maxRow = Math.max(startIndex, targetIndex);
  const minDay = Math.min(startDay, targetDay);
  const maxDay = Math.max(startDay, targetDay);

  // 矩形範囲のキー集合
  const rectKeys = new Set();
  table.querySelectorAll(`td[data-row-type="${startRowType}"]`).forEach(c=>{
    const rIdx = parseInt(c.dataset.rowIndex,10);
    const d = parseInt(c.dataset.day,10);
    if(rIdx>=minRow && rIdx<=maxRow && d>=minDay && d<=maxDay){
      rectKeys.add(cellKey(c));
    }
  });
  dragLastRectKeys = rectKeys;

  // Ctrlドラッグは「プレビュー」を表示し、確定は mouseup で行う
  if(dragAdditive && dragBaseSelectionKeys){
    clearDragPreview();

    const base = dragBaseSelectionKeys;
    if(dragRangeMode === "add"){
      // 追加候補（まだ選択されていないもの）
      const pending = new Set();
      rectKeys.forEach(k=>{ if(!base.has(k)) pending.add(k); });

      // 表示上は base ∪ pending を選択状態にする
      const display = new Set(base);
      pending.forEach(k=>display.add(k));
      applySelectionKeys(display, null);

      // pending をプレビュー強調
      pending.forEach(k=>{ const c=getCellByKey(k); if(c) c.classList.add("cell-preview-add"); });
      setDragHint("add", pending.size);
      return;
    }

    if(dragRangeMode === "remove"){
      // 解除候補（既に選択されているものだけ）
      const pending = new Set();
      rectKeys.forEach(k=>{ if(base.has(k)) pending.add(k); });

      // 表示上の選択は base のまま維持（消さない）
      applySelectionKeys(base, null);

      // pending をプレビュー強調（取り消し線）
      pending.forEach(k=>{ const c=getCellByKey(k); if(c) c.classList.add("cell-preview-remove"); });
      setDragHint("remove", pending.size);
      return;
    }
  }

  // 通常（置換/非Ctrl）
  // 範囲選択（置換）中は確定前プレビューとして青の破線を表示（確定は mouseup）
  if(!dragAdditive && dragRangeMode === "replace" && pointerDown){
    clearDragPreview();
    applySelectionKeys(rectKeys, null);
    // 始点セルはgetCellByKeyの揺れに関係なく必ず破線プレビューを付ける
    try{ dragStartCell.classList.add('cell-preview-add'); }catch(_){ }

    rectKeys.forEach(k=>{ const c=getCellByKey(k); if(c) c.classList.add('cell-preview-add'); });
    // ヒントは通常は出さない（必要ならここで setDragHint('add', rectKeys.size) 可能）
    return;
  }

  // 通常（置換/非Ctrl）は従来通り即時反映
  clearDragPreview();
  if(dragRangeMode === "replace"){
    applySelectionKeys(rectKeys, null);
  }else if(dragRangeMode === "add"){
    const next = new Set(selectedKeySet);
    rectKeys.forEach(k=>next.add(k));
    applySelectionKeys(next, targetCell);
  }else if(dragRangeMode === "remove"){
    const next = new Set(selectedKeySet);
    rectKeys.forEach(k=>next.delete(k));
    if(next.size===0) next.add(cellKey(dragStartCell));
    applySelectionKeys(next, targetCell);
  }
}




/* ===== Key handling ===== */

function getVisibleMaxDay(){
  try{
    const table = document.getElementById('scheduleTable');
    if(!table) return 31;
    const ths = table.querySelectorAll('thead th[data-day]');
    if(ths && ths.length){
      let max = 1;
      ths.forEach(th=>{
        const d = parseInt(th.dataset.day,10);
        if(!Number.isNaN(d) && d>max) max = d;
      });
      return max || 31;
    }
    const tds = table.querySelectorAll('td[data-day]');
    let max = 1;
    tds.forEach(td=>{
      const d = parseInt(td.dataset.day,10);
      if(!Number.isNaN(d) && d>max) max = d;
    });
    return max || 31;
  }catch(_){ return 31; }
}

function getRowIndexList(rowType){
  const table = document.getElementById('scheduleTable');
  if(!table) return [0];
  const set = new Set();
  table.querySelectorAll(`td[data-row-type="${rowType}"]`).forEach(c=>{
    const r = parseInt(c.dataset.rowIndex,10);
    if(!Number.isNaN(r)) set.add(r);
  });
  const arr = Array.from(set).sort((a,b)=>a-b);
  return arr.length ? arr : [0];
}

function getMaxRowIndexForRowType(rowType){
  const table = document.getElementById('scheduleTable');
  if(!table) return 0;
  let max = 0;
  table.querySelectorAll(`td[data-row-type="${rowType}"]`).forEach(c=>{
    const r = parseInt(c.dataset.rowIndex,10);
    if(r>max) max=r;
  });
  return max;
}
function getCellByRowDay(rowType, rowIndex, day){
  const table = document.getElementById('scheduleTable');
  if(!table) return null;
  return table.querySelector(`td[data-row-type="${rowType}"][data-row-index="${rowIndex}"][data-day="${day}"]`);
}
function buildRectKeys(anchorCell, focusCell){
  const table = document.getElementById('scheduleTable');
  if(!table || !anchorCell || !focusCell) return new Set();
  const rowType = anchorCell.dataset.rowType;
  if(focusCell.dataset.rowType !== rowType) return new Set();

  const aRow = parseInt(anchorCell.dataset.rowIndex,10);
  const fRow = parseInt(focusCell.dataset.rowIndex,10);
  const aDay = parseInt(anchorCell.dataset.day,10);
  const fDay = parseInt(focusCell.dataset.day,10);

  const minRow = Math.min(aRow, fRow);
  const maxRow = Math.max(aRow, fRow);
  const minDay = Math.min(aDay, fDay);
  const maxDay = Math.max(aDay, fDay);

  const keys = new Set();
  table.querySelectorAll(`td[data-row-type="${rowType}"]`).forEach(c=>{
    const r = parseInt(c.dataset.rowIndex,10);
    const d = parseInt(c.dataset.day,10);
    if(r>=minRow && r<=maxRow && d>=minDay && d<=maxDay){
      keys.add(cellKey(c));
    }
  });
  return keys;
}

function handleCellKeyDown(e, cell){
  const rowType=cell.dataset.rowType;
  if(rowType==="support") return;

  if(e.isComposing || e.key==="Process"){ showIMEAlert(); return; }

  
  // Shift+矢印：矩形範囲選択（アクティブを起点、循環なし）
  if(rowType!=="note" && e.shiftKey && !e.ctrlKey && !e.metaKey && (e.key==="ArrowLeft"||e.key==="ArrowRight"||e.key==="ArrowUp"||e.key==="ArrowDown")){
    // NumLock OFFテンキーは入力用途と衝突するので対象外
    if(typeof e.code==="string" && e.code.startsWith("Numpad")){
      // pass
    }else{
      e.preventDefault();
      const base = shiftAnchorCell || activeCell || cell;
      if(!base) return;
      if(!shiftAnchorCell) shiftAnchorCell = base;

      const rowType = base.dataset.rowType;
      const maxDay = getVisibleMaxDay();
      const maxRow = getMaxRowIndexForRowType(rowType);

      let r = parseInt((activeCell||cell).dataset.rowIndex,10);
      let d = parseInt((activeCell||cell).dataset.day,10);

      if(e.key==="ArrowLeft")  d = Math.max(1, d-1);
      if(e.key==="ArrowRight") d = Math.min(maxDay, d+1);
      if(e.key==="ArrowUp")    r = Math.max(0, r-1);
      if(e.key==="ArrowDown")  r = Math.min(maxRow, r+1);

      const next = getCellByRowDay(rowType, r, d);
      if(!next) return;

      const rectKeys = buildRectKeys(shiftAnchorCell, next);
      pointerDown = false; // committing扱い
      applySelectionKeys(rectKeys, next);
      try{ next.focus({preventScroll:true}); }catch(_){ try{ next.focus(); }catch(__){} }
      return;
    }
  }

// 十字キーでセル移動（Tab/Enter相当）。※循環（端から次/前の従業員へ）はしない
  // NumLock OFF のテンキーは e.key が ArrowUp 等になるため、code が Numpad の場合は移動に使わない（コード入力に回す）
  if(e.key==="ArrowLeft" || e.key==="ArrowRight" || e.key==="ArrowUp" || e.key==="ArrowDown"){
    if(typeof e.code==="string" && e.code.startsWith("Numpad")){
      // テンキー（NumLock OFF含む）は入力用途として扱う
    }else{
      e.preventDefault();
      if(selectedCells.length>1){ clearSelection(); setActiveCell(cell,false); }
      if(e.key==="ArrowLeft")  return moveFocusByDayNoWrap(cell, -1);
      if(e.key==="ArrowRight") return moveFocusByDayNoWrap(cell,  1);
      if(e.key==="ArrowUp")    return moveFocusByEmployeeNoWrap(cell, -1);
      if(e.key==="ArrowDown")  return moveFocusByEmployeeNoWrap(cell,  1);
    }
  }


  if(e.key==="Tab"){
    e.preventDefault();
    if(selectedCells.length>1){ clearSelection(); setActiveCell(cell,false); }
    moveFocusByDay(cell, e.shiftKey ? -1 : 1);
    return;
  }
  if(e.key==="Enter"){
    e.preventDefault();
    if(selectedCells.length>1){ clearSelection(); setActiveCell(cell,false); }
    moveFocusByEmployee(cell, e.shiftKey ? -1 : 1);
    return;
  }
  if(rowType!=="note" && (e.key==="Delete" || e.key==="Backspace")){
    e.preventDefault();
    handleDeleteKey();
    return;
  }
  if(rowType==="note") return;

  if(isCellReadonly(cell)){ e.preventDefault(); return; }

  // 数字入力は document 側のハンドラで一元処理（重複入力防止）

  if(/^[a-zA-Z]$/.test(e.key)){
    e.preventDefault();
    handleLetterInput(e.key.toUpperCase());
    return;
  }
}

function isCellReadonly(cell){
  const val=(cell.textContent||"").trim();
  return val.includes("ﾋ");
}

function moveFocusByDayNoWrap(cell, dir){
  const schedule=getCurrentSchedule();
  if(!schedule) return;
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);
  const day=Number(cell.dataset.day);
  const rowType=cell.dataset.rowType;
  const empId=Number(cell.dataset.empId);

  const newDay=day+dir;
  if(newDay<1 || newDay>daysInMonth) return; // 循環しない

  focusCellByPosition(empId, rowType, newDay);
}

function moveFocusByEmployeeNoWrap(cell, dir){
  const schedule=getCurrentSchedule();
  if(!schedule) return;
  const day=Number(cell.dataset.day);
  const rowType=cell.dataset.rowType;
  const empId=Number(cell.dataset.empId);

  const employees=getEmployeesInStore(schedule,currentStoreId);
  const index=employees.findIndex(e=>e.id===empId);
  const newIndex=index+dir;
  if(newIndex<0 || newIndex>=employees.length) return; // 循環しない

  focusCellByPosition(employees[newIndex].id, rowType, day);
}

function moveFocusByDay(cell, dir){
  const schedule=getCurrentSchedule();
  if(!schedule) return;
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);
  const day=Number(cell.dataset.day);
  const rowType=cell.dataset.rowType;
  const empId=Number(cell.dataset.empId);
  const employees=getEmployeesInStore(schedule,currentStoreId);
  const index=employees.findIndex(e=>e.id===empId);

  let newDay=day+dir;
  let newEmpIndex=index;

  if(newDay<1){
    newEmpIndex -= 1;
    if(newEmpIndex<0) newEmpIndex=employees.length-1;
    newDay=daysInMonth;
  }else if(newDay>daysInMonth){
    newEmpIndex += 1;
    if(newEmpIndex>=employees.length) newEmpIndex=0;
    newDay=1;
  }
  focusCellByPosition(employees[newEmpIndex].id, rowType, newDay);
}

function moveFocusByEmployee(cell, dir){
  const schedule=getCurrentSchedule();
  if(!schedule) return;
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);
  const day=Number(cell.dataset.day);
  const rowType=cell.dataset.rowType;
  const empId=Number(cell.dataset.empId);

  const employees=getEmployeesInStore(schedule,currentStoreId);
  const index=employees.findIndex(e=>e.id===empId);

  let newEmpIndex=index+dir;
  let newDay=day;
  if(newEmpIndex<0){
    newEmpIndex=employees.length-1;
    newDay=Math.max(1, day-1);
  }else if(newEmpIndex>=employees.length){
    newEmpIndex=0;
    newDay=Math.min(daysInMonth, day+1);
  }
  focusCellByPosition(employees[newEmpIndex].id, rowType, newDay);
}

function focusCellByPosition(empId, rowType, day){
  const table=document.getElementById("scheduleTable");
  if(!table) return;
  const target=table.querySelector(`td[data-row-type="${rowType}"][data-emp-id="${empId}"][data-day="${day}"]`);
  if(target){ target.focus(); setActiveCell(target,false); }
}

function computeNextByDaySteps(schedule, storeId, empId, rowType, day, steps){
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);
  const employees=getEmployeesInStore(schedule,storeId);
  let idx=employees.findIndex(e=>e.id===empId);
  let d=day;
  for(let i=0;i<steps;i++){
    d+=1;
    if(d>daysInMonth){
      d=1;
      idx+=1;
      if(idx>=employees.length) idx=0;
    }
  }
  return {empId:employees[idx].id, rowType, day:d};
}

/* ===== Input apply ===== */
function handleNumericInput(num){
  const schedule=getCurrentSchedule();
  if(!schedule||!activeCell) return;
  if(activeCell.dataset.rowType!=="main") return;

  const mode=getInputMode();
  const snapshot=schedule.masterSnapshot;

  if(mode==="leave"){
    const lc=snapshot.leaveCodes.find(l=>l.key===String(num));
    if(!lc) return;
    applyCodeToSelection({kind:"leave",code:lc.code}, schedule);
  }else{
    const wc=snapshot.workCodes.find(w=>w.key===String(num));
    if(!wc) return;
    if(isSupportMode && !(wc.code==="E"||wc.code==="F")) return;

    const ctxStoreId=getWorkContextStoreId();
    const ctxStore=snapshot.stores.find(s=>s.id===ctxStoreId);
    if(!ctxStore) return;
    const perStore=(ctxStore.storeCodes||[]).find(sc=>sc.code===wc.code);
    if(!perStore || perStore.type==="disabled") return;

    applyCodeToSelection({kind:"work",code:wc.code,shiftType:perStore.type}, schedule);
  }
}

function handleLetterInput(letter){
  const schedule=getCurrentSchedule();
  if(!schedule||!activeCell) return;
  if(activeCell.dataset.rowType!=="main") return;

  if(getInputMode()!=="work") return;
  const snapshot=schedule.masterSnapshot;
  const wc=snapshot.workCodes.find(w=>w.code===letter);
  if(!wc) return;

  const ctxStoreId=getWorkContextStoreId();
  const ctxStore=snapshot.stores.find(s=>s.id===ctxStoreId);
  if(!ctxStore) return;

  const perStore=(ctxStore.storeCodes||[]).find(sc=>sc.code===wc.code);
  if(!perStore || perStore.type==="disabled") return;

  applyCodeToSelection({kind:"work",code:wc.code,shiftType:perStore.type}, schedule);
}

function getWorkContextStoreId(){
  if(!isSupportMode) return currentStoreId;
  const id=Number(dom.supportStoreSelect.value);
  return id || currentStoreId;
}

function getSupportPrefix(snapshot){
  if(!isSupportMode) return "";
  const targetId=Number(dom.supportStoreSelect.value);
  const store=snapshot.stores.find(s=>s.id===targetId);
  return store?.shortName || "";
}

function applyCodeToSelection(codeInfo, schedule){
  if(!activeCell) return;
  const cells=(selectedCells.length>0?selectedCells.slice():[activeCell]);
  const rowType=activeCell.dataset.rowType;
  const filtered=cells.filter(c=>c.dataset.rowType===rowType);
  if(rowType!=="main") return;

  const isMulti=filtered.length>1;

  if(isMulti){
    // 複数セル入力時は選択を維持したまま再描画（選択解除＆フォーカス移動をしない）
    preserveSelectionOnRender=true;
    preserveSelectionKeys=new Set(selectedKeySet);
    preserveSelectionActiveKey=activeCell ? cellKey(activeCell) : null;
  }
  const isNight = (codeInfo.kind==="work" && codeInfo.shiftType==="night");
  const targetCells = isNight ? filtered.filter(c=>!isCellReadonly(c)) : filtered;
  if(targetCells.length===0) return;

  const snapshot=schedule.masterSnapshot;
  const prefix = (codeInfo.kind==="work") ? getSupportPrefix(snapshot) : "";

  if(codeInfo.kind==="leave"){
    targetCells.forEach(cell=>{
      const empId=Number(cell.dataset.empId);
      const day=Number(cell.dataset.day);
      // 夜勤ペアの孤立防止：上書き前に関連セルも掃除
      clearPairedNightIfNeeded(schedule,currentStoreId,empId,day);
      setAssignmentValue(schedule,currentStoreId,empId,"main",day,codeInfo.code);
    });
    if(!isMulti){
      const empId=Number(activeCell.dataset.empId);
      const day=Number(activeCell.dataset.day);
      pendingFocus=computeNextByDaySteps(schedule,currentStoreId,empId,"main",day,1);
    }
  }else if(codeInfo.kind==="work" && codeInfo.shiftType==="night"){
    applyNightCode(schedule, targetCells, prefix, codeInfo.code);
    if(!isMulti){
      const empId=Number(activeCell.dataset.empId);
      const day=Number(activeCell.dataset.day);
      pendingFocus=computeNextByDaySteps(schedule,currentStoreId,empId,"main",day,2);
    }
  }else{
    const value=prefix + codeInfo.code;
    targetCells.forEach(cell=>{
      const empId=Number(cell.dataset.empId);
      const day=Number(cell.dataset.day);
      // 夜勤ペアの孤立防止：上書き前に関連セルも掃除
      clearPairedNightIfNeeded(schedule,currentStoreId,empId,day);
      setAssignmentValue(schedule,currentStoreId,empId,"main",day,value);
    });
    if(!isMulti){
      const empId=Number(activeCell.dataset.empId);
      const day=Number(activeCell.dataset.day);
      pendingFocus=computeNextByDaySteps(schedule,currentStoreId,empId,"main",day,1);
    }
  }
  renderSchedule();
}

function applyNightCode(schedule, cells, prefix, codeLetter){
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);
  const valueStart=prefix+codeLetter+"ﾃ";
  const valueEnd=prefix+codeLetter+"ﾋ";

  const grouped={};
  cells.forEach(cell=>{
    const empId=Number(cell.dataset.empId);
    const day=Number(cell.dataset.day);
    if(!grouped[empId]) grouped[empId]=[];
    grouped[empId].push(day);
  });

  Object.keys(grouped).forEach(empIdStr=>{
    const empId=Number(empIdStr);
    const days=grouped[empId].sort((a,b)=>a-b);

    for(let i=0;i<days.length;i+=2){
      const d=days[i];
      if(!d) continue;

      // 既存の夜勤ペアがあれば先に掃除（ﾋ孤立防止・上書き衝突回避）
      clearPairedNightIfNeeded(schedule,currentStoreId,empId,d);
      setAssignmentValue(schedule,currentStoreId,empId,"main",d,valueStart);

      if(d<daysInMonth){
        // 翌日セルが既存の夜勤開始(ﾃ)だった場合、そのペアも掃除してから上書き
        clearPairedNightIfNeeded(schedule,currentStoreId,empId,d+1);
        setAssignmentValue(schedule,currentStoreId,empId,"main",d+1,valueEnd);
      }else{
        const nextYm=nextMonthKey(currentYearMonth);
        const nextSchedule=appState.schedules[nextYm];

        if(nextSchedule && nextSchedule.byStore[currentStoreId] && nextSchedule.byStore[currentStoreId].assignments[empId]){
          // 次月1日が既存の夜勤明け/入りだった場合も孤立しないよう掃除してから上書き
          clearPairedNightIfNeeded(nextSchedule,currentStoreId,empId,1);
          nextSchedule.byStore[currentStoreId].assignments[empId].main[0]=valueEnd;
          markDirty();
        }else{
          if(!appState.pendingNightCarryovers[nextYm]) appState.pendingNightCarryovers[nextYm]={};
          if(!appState.pendingNightCarryovers[nextYm][currentStoreId]) appState.pendingNightCarryovers[nextYm][currentStoreId]={};
          if(!appState.pendingNightCarryovers[nextYm][currentStoreId][empId]) appState.pendingNightCarryovers[nextYm][currentStoreId][empId]={};
          appState.pendingNightCarryovers[nextYm][currentStoreId][empId]["1"]=valueEnd;
          markDirty();
        }
      }
    }
  });
}

/* ===== Delete / Backspace ===== */
function handleDeleteKey(){
  const schedule=getCurrentSchedule();
  if(!schedule) return;
  // 削除後もアクティブセルを維持するため、現在の位置を控えておく
  const focusAfterDelete = activeCell ? {
    empId: Number(activeCell.dataset.empId),
    rowType: activeCell.dataset.rowType,
    day: Number(activeCell.dataset.day)
  } : null;
  const cells=(selectedCells.length>0?selectedCells.slice():[activeCell]).filter(Boolean);
  if(cells.length===0) return;

  const isMultiSelection = (selectedKeySet && selectedKeySet.size>1) || (selectedCells && selectedCells.length>1);
  if(isMultiSelection){
    // 複数セル削除時は選択を維持したまま再描画（選択解除＆フォーカス移動をしない）
    preserveSelectionOnRender=true;
    preserveSelectionKeys=new Set(selectedKeySet);
    preserveSelectionActiveKey=activeCell ? cellKey(activeCell) : null;
  }

  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);

  cells.forEach(cell=>{
    const rowType=cell.dataset.rowType;
    if(rowType==="support") return;
    const empId=Number(cell.dataset.empId);
    const day=Number(cell.dataset.day);
    const storeId=currentStoreId;

    const val=getAssignmentValue(schedule,storeId,empId,rowType,day);

    if(rowType==="main" && val){
      const parsed=parseCellValue(val, schedule.masterSnapshot);
      if(parsed.isNight && parsed.nightPart==="start"){
        setAssignmentValue(schedule,storeId,empId,"main",day,"");
        if(day<daysInMonth){
          const nextVal=getAssignmentValue(schedule,storeId,empId,"main",day+1);
          if(nextVal.includes("ﾋ")) setAssignmentValue(schedule,storeId,empId,"main",day+1,"");
        }else{
          const nextYm=nextMonthKey(currentYearMonth);
          const nextSchedule=appState.schedules[nextYm];
          if(nextSchedule && nextSchedule.byStore[storeId] && nextSchedule.byStore[storeId].assignments[empId]){
            const nextVal=getAssignmentValue(nextSchedule,storeId,empId,"main",1);
            if(nextVal.includes("ﾋ")) setAssignmentValue(nextSchedule,storeId,empId,"main",1,"");
          }
          const p=appState.pendingNightCarryovers?.[nextYm]?.[storeId]?.[empId];
          if(p && p["1"]){ delete p["1"]; markDirty(); }
        }
      }else if(parsed.isNight && parsed.nightPart==="end"){
        setAssignmentValue(schedule,storeId,empId,"main",day,"");
        if(day>1){
          const prevVal=getAssignmentValue(schedule,storeId,empId,"main",day-1);
          if(prevVal.includes("ﾃ")) setAssignmentValue(schedule,storeId,empId,"main",day-1,"");
        }
      }else{
        setAssignmentValue(schedule,storeId,empId,"main",day,"");
      }
    }else{
      setAssignmentValue(schedule,storeId,empId,rowType,day,"");
    }
  });

  if(focusAfterDelete){ pendingFocus = focusAfterDelete; }
  renderSchedule();
}

/* ===== Cell render (color/readonly) ===== */
function renderCellValue(cell, value, schedule, currentStoreIdForTable){
  cell.textContent=value||"";
  cell.classList.remove("cell-bg-colored","cell-work-text","cell-readonly");
  cell.style.backgroundColor="";
  cell.style.color="";
  if(!value) return;
  if(cell.dataset.rowType!=="main") return;
  if(value.includes("ﾋ")) cell.classList.add("cell-readonly");

  const snapshot=schedule.masterSnapshot;
  const parsed=parseCellValue(value, snapshot);
  if(!parsed.workCode) return;

  const work=snapshot.workCodes.find(w=>w.code===parsed.workCode);
  if(!work) return;
  cell.classList.add("cell-work-text");
  cell.style.color=work.color;

  const contextStoreId=parsed.contextStoreId || currentStoreIdForTable;
  const ctxStore=snapshot.stores.find(s=>s.id===contextStoreId);
  const perStore=(ctxStore?.storeCodes||[]).find(sc=>sc.code===parsed.workCode);
  const isNight=perStore?.type==="night";

  if(!isNight || (isNight && parsed.nightPart==="start")){
    cell.style.backgroundColor=work.bgColor;
    cell.classList.add("cell-bg-colored");
  }
}

function parseCellValue(value, snapshot){
  let isNight=false, nightPart=null, workCode="", storePrefix="", contextStoreId=null;
  if(!value) return {isNight,nightPart,workCode,storePrefix,contextStoreId};

  const last=value[value.length-1];
  if(last==="ﾃ" || last==="ﾋ"){
    isNight=true;
    nightPart = (last==="ﾃ") ? "start" : "end";
    const core=value.slice(0,-1);
    if(core.length===1 && /^[A-Z]$/.test(core[0])){
      workCode=core[0];
    }else if(core.length>=2 && /^[A-Z]$/.test(core[core.length-1])){
      storePrefix=core[0];
      workCode=core[core.length-1];
    }
  }else{
    if(value.length>=2 && /^[A-Z]$/.test(value[1])){
      storePrefix=value[0];
      workCode=value[1];
    }else if(value.length===1 && /^[A-Z]$/.test(value[0])){
      workCode=value[0];
    }
  }
  if(storePrefix){
    const store=snapshot.stores.find(s=>s.shortName===storePrefix);
    if(store) contextStoreId=store.id;
  }
  return {isNight,nightPart,workCode,storePrefix,contextStoreId};
}

/* ===== Night pair cleanup helpers ===== */
// 夜勤入り(ﾃ)を消す/上書きする場合に、翌日の夜勤明け(ﾋ)が孤立しないよう必ず消す。
// 逆に夜勤明け(ﾋ)を消す/上書きする場合も、前日の夜勤入り(ﾃ)を消す。
function clearPairedNightIfNeeded(schedule, storeId, empId, day){
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);
  const val=getAssignmentValue(schedule,storeId,empId,"main",day);
  if(!val) return;
  const parsed=parseCellValue(val, schedule.masterSnapshot);
  if(!parsed.isNight) return;

  if(parsed.nightPart==="start"){
    // 同月内：翌日がﾋなら消す（コードが一致しなくても孤立回避のため消す）
    if(day < daysInMonth){
      const nextVal=getAssignmentValue(schedule,storeId,empId,"main",day+1);
      if(nextVal && nextVal.includes("ﾋ")){
        setAssignmentValue(schedule,storeId,empId,"main",day+1,"");
      }
    }else{
      // 月末：翌月1日のﾋ（または保留キャリー）を消す
      const nextYm=nextMonthKey(currentYearMonth);
      const nextSchedule=appState.schedules[nextYm];
      if(nextSchedule && nextSchedule.byStore?.[storeId]?.assignments?.[empId]){
        const nextVal=getAssignmentValue(nextSchedule,storeId,empId,"main",1);
        if(nextVal && nextVal.includes("ﾋ")){
          setAssignmentValue(nextSchedule,storeId,empId,"main",1,"");
        }
      }
      const p=appState.pendingNightCarryovers?.[nextYm]?.[storeId]?.[empId];
      if(p && p["1"]){
        delete p["1"];
        markDirty();
      }
    }
  }else if(parsed.nightPart==="end"){
    // 同月内：前日がﾃなら消す
    if(day > 1){
      const prevVal=getAssignmentValue(schedule,storeId,empId,"main",day-1);
      if(prevVal && prevVal.includes("ﾃ")){
        setAssignmentValue(schedule,storeId,empId,"main",day-1,"");
      }
    }else{
      // 月初：前月末のﾃを消す（存在する場合）
      const prevYm=prevMonthKey(currentYearMonth);
      const prevSchedule=appState.schedules[prevYm];
      if(prevSchedule && prevSchedule.byStore?.[storeId]?.assignments?.[empId]){
        const prevDays=getDaysInMonth(prevSchedule.year, prevSchedule.month);
        const prevVal=getAssignmentValue(prevSchedule,storeId,empId,"main",prevDays);
        if(prevVal && prevVal.includes("ﾃ")){
          setAssignmentValue(prevSchedule,storeId,empId,"main",prevDays,"");
        }
      }
    }
  }
}

function prevMonthKey(ym){
  const [yStr,mStr]=ym.split("-");
  let y=parseInt(yStr,10), m=parseInt(mStr,10);
  m-=1; if(m<1){ m=12; y-=1; }
  return `${y.toString().padStart(4,"0")}-${m.toString().padStart(2,"0")}`;
}


/* ===== Night consistency check (current month only) ===== */
function validateNightShiftsForCurrent(){
  dom.alertList.innerHTML="";
  if(!currentSchedule || !currentStoreSchedule) return;

  const schedule=currentSchedule;
  const storeId=currentStoreId;
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);

  const errors=[];
  const employees=getEmployeesInStore(schedule, storeId);

  const table=document.getElementById("scheduleTable");
  if(table) table.querySelectorAll("td").forEach(td=>td.classList.remove("cell-error"));

  employees.forEach(emp=>{
    for(let d=1; d<=daysInMonth; d++){
      const v=getAssignmentValue(schedule,storeId,emp.id,"main",d);
      if(!v) continue;
      const parsed=parseCellValue(v, schedule.masterSnapshot);
      if(!parsed.isNight) continue;

      const cell = table?.querySelector(`td[data-row-type="main"][data-emp-id="${emp.id}"][data-day="${d}"]`);
      if(parsed.nightPart==="start"){
        if(d===daysInMonth) continue;
        const nextVal=getAssignmentValue(schedule,storeId,emp.id,"main",d+1);
        if(!nextVal || !nextVal.includes("ﾋ")){
          if(cell) cell.classList.add("cell-error");
          errors.push(`${emp.lastName}${emp.firstName}：${d}日「夜勤入り」の翌日が「夜勤明け」になっていません。`);
        }
      }else if(parsed.nightPart==="end"){
        if(d===1) continue;
        const prevVal=getAssignmentValue(schedule,storeId,emp.id,"main",d-1);
        if(!prevVal || !prevVal.includes("ﾃ")){
          if(cell) cell.classList.add("cell-error");
          errors.push(`${emp.lastName}${emp.firstName}：${d}日「夜勤明け」の前日が「夜勤入り」になっていません。`);
        }
      }
    }
  });

  if(errors.length===0){
    const item=document.createElement("div");
    item.className="alert-item good";
    item.textContent="夜勤コードの不整合は検出されませんでした。";
    dom.alertList.appendChild(item);
  }else{
    errors.forEach(msg=>{
      const item=document.createElement("div");
      item.className="alert-item";
      item.textContent=msg;
      dom.alertList.appendChild(item);
    });
  }
}

/* ===== Support info (read only) ===== */
function getSupporterFor(schedule, targetStoreId, codeLetter, day){
  const snapshot=schedule.masterSnapshot;
  const targetStore=snapshot.stores.find(s=>s.id===targetStoreId);
  if(!targetStore || !targetStore.shortName) return "";
  const shortName=targetStore.shortName;

  for(const storeIdStr of Object.keys(schedule.byStore)){
    const storeId=Number(storeIdStr);
    const storeData=schedule.byStore[storeId];
    if(!storeData) continue;
    const assignments=storeData.assignments;
    for(const empIdStr of Object.keys(assignments)){
      const empId=Number(empIdStr);
      const val=assignments[empId].main[day-1] || "";
      if(!val) continue;
      const parsed=parseCellValue(val, snapshot);
      if(parsed.storePrefix===shortName && parsed.workCode===codeLetter){
        const emp=snapshot.employees.find(e=>e.id===empId);
        if(emp) return emp.lastName;
      }
    }
  }
  return "";
}


function getLatestYearMonthKey(){
  const keys=Object.keys(appState?.schedules || {});
  if(keys.length===0) return null;
  keys.sort(); // YYYY-MM なので辞書順でOK
  return keys[keys.length-1];
}
function isCurrentYearMonthLatest(){
  const latest=getLatestYearMonthKey();
  return !!latest && latest===currentYearMonth;
}


function updateSettingsScopeUI(){ /* v84: scope UI removed */ }


function getSettingsMasterTarget(){
  if(settingsScope==="current"){
    const schedule=getCurrentSchedule();
    return schedule ? schedule.masterSnapshot : null;
  }
  return appState.templateMaster;
}

/* ===== Settings UI ===== */
function populateSettingsFromState(){
  const master=getSettingsMasterTarget();
  if(!master){ alert('この年月の勤務表が未作成です。'); return; }

  dom.storeTableBody.innerHTML="";
  master.stores.slice().sort((a,b)=>(a.order||0)-(b.order||0)).forEach(store=>addStoreRow(store));

  dom.employeeTableBody.innerHTML="";
  master.employees.forEach(emp=>addEmployeeRow(emp));
  refreshEmployeeStoreOptionsFromSettings();
  refreshEmployeeOrderPanel();

  dom.workCodeTableBody.innerHTML="";
  master.workCodes.forEach(wc=>{
    const tr=document.createElement("tr");
    tr.dataset.code=wc.code;
    tr.innerHTML = `
      <td style="font-weight:800;">${wc.code}</td>
      <td><input type="number" min="0" max="9" value="${escapeHtml(wc.key||"")}"></td>
      <td><input type="color" value="${escapeHtml(wc.color||"#000000")}"></td>
      <td><input type="color" value="${escapeHtml(wc.bgColor||"#ffffff")}"></td>`;
    dom.workCodeTableBody.appendChild(tr);
  });

  dom.leaveCodeTableBody.innerHTML="";
  master.leaveCodes.forEach(lc=>addLeaveCodeRow(lc));
}

function saveSettingsFromUI(){
  const master=getSettingsMasterTarget();
  if(!master){ alert('この年月の勤務表が未作成です。'); return; }

  const stores=[];
  const storeIdMap = new Map(); // 仮ID(負数) -> 実ID
  const rows=Array.from(dom.storeTableBody.querySelectorAll("tr"));
  rows.forEach((tr,idx)=>{
    let id=Number(tr.dataset.id);
    if(!Number.isFinite(id)) id=0;
    if(id<=0){
      const old=id;
      id = master.nextStoreId++;
      storeIdMap.set(String(old), String(id));
    }
    const name=tr.querySelector(".store-name").value.trim();
    const shortName=tr.querySelector(".store-short").value.trim();
    const enabled=tr.querySelector(".store-enabled").checked;

    const storeCodes=[];
    tr.querySelectorAll(".store-code-setting").forEach(sel=>{
      storeCodes.push({code:sel.dataset.code, type:sel.value});
    });
    stores.push({id,name,shortName,enabled,order:idx+1,storeCodes});
  });

  const nameSet=new Set();
  const shortSet=new Set();
  for(const s of stores){
    if(!s.name){ alert("店舗名が空の行があります。"); return; }
    if(!s.shortName){ alert("店舗略称が空の行があります。"); return; }
    if(nameSet.has(s.name)){ alert("店舗名が重複しています: "+s.name); return; }
    if(shortSet.has(s.shortName)){ alert("店舗略称が重複しています: "+s.shortName); return; }
    nameSet.add(s.name); shortSet.add(s.shortName);
  }
  master.stores=stores;
  master.nextStoreId=stores.reduce((mx,s)=>Math.max(mx,s.id),0)+1;

  const employees=[];
  Array.from(dom.employeeTableBody.querySelectorAll("tr")).forEach(tr=>{
    const id=Number(tr.dataset.id)||master.nextEmployeeId++;
    const lastName=tr.querySelector(".emp-last").value.trim();
    const firstName=tr.querySelector(".emp-first").value.trim();
    const storeIdStr=tr.querySelector(".emp-store").value||"";
    let storeId = storeIdStr ? Number(storeIdStr) : null;
    if(storeId!=null && storeId<=0 && storeIdMap.has(String(storeId))){
      storeId = Number(storeIdMap.get(String(storeId)));
    }
    const orderInStore = (Number(tr.querySelector(".emp-order").value)||9999) * 10; // 表示(1刻み)→内部(10刻み)
    employees.push({id,lastName,firstName,storeId,orderInStore});
  });

  const fullSet=new Set();
  for(const e of employees){
    if(!e.lastName || !e.firstName){ alert("従業員の姓/名が空の行があります。"); return; }
    const k=e.lastName+" "+e.firstName;
    if(fullSet.has(k)){ alert("従業員の同姓同名が重複しています: "+k); return; }
    fullSet.add(k);
  }
  master.employees=employees;
  master.nextEmployeeId=employees.reduce((mx,e)=>Math.max(mx,e.id),0)+1;

  Array.from(dom.workCodeTableBody.querySelectorAll("tr")).forEach(tr=>{
    const code=tr.dataset.code;
    const inputs=tr.querySelectorAll("input");
    const key=inputs[0].value.trim();
    const color=inputs[1].value;
    const bgColor=inputs[2].value;
    const wc=master.workCodes.find(w=>w.code===code);
    if(!wc) return;
    wc.key=key; wc.color=color; wc.bgColor=bgColor;
  });

  const leaveCodes=[];
  Array.from(dom.leaveCodeTableBody.querySelectorAll("tr")).forEach(tr=>{
    const code=tr.querySelector(".leave-code").value.trim();
    const key=tr.querySelector(".leave-key").value.trim();
    if(!code) return;
    leaveCodes.push({code,key});
  });
  master.leaveCodes=leaveCodes;


  // この月（勤務表スナップショット）を編集している場合：勤務表データ構造（byStore.assignments）をスナップショットに合わせて補正する
  const schedule=getCurrentSchedule();
  if(schedule){
    reconcileScheduleDataWithSnapshot(schedule);

    // 既存の最新勤務表を編集している場合のみ、チェックONでテンプレ（今後の新規作成用）にも反映
    const propagateCb=document.getElementById('propagateToTemplateCheckbox');
    const canPropagate=isCurrentYearMonthLatest();
    if(canPropagate && propagateCb && propagateCb.checked){
      appState.templateMaster = deepClone(schedule.masterSnapshot);
    }
  }

}


function setStoreCodeDot(dotEl, mode){
  dotEl.classList.remove("dot-day","dot-night","dot-disabled");
  if(mode==="night") dotEl.classList.add("dot-night");
  else if(mode==="disabled") dotEl.classList.add("dot-disabled");
  else dotEl.classList.add("dot-day");
}

function addStoreRow(store){
  const master=getSettingsMasterTarget() || appState.templateMaster;
  const workCodes=master.workCodes;
  const tr=document.createElement("tr");
  tr.dataset.id = store ? store.id : String(settingsTempStoreId--);

  const tdMove=document.createElement("td");
  tdMove.style.whiteSpace="nowrap";
  const up=document.createElement("button"); up.textContent="↑"; up.className="icon"; up.style.padding="6px 10px";
  up.addEventListener("click",()=>moveRow(tr,-1));
  const down=document.createElement("button"); down.textContent="↓"; down.className="icon"; down.style.padding="6px 10px";
  down.addEventListener("click",()=>moveRow(tr,1));
  tdMove.appendChild(up); tdMove.appendChild(down);

  const tdName=document.createElement("td");
  const inputName=document.createElement("input");
  inputName.type="text"; inputName.className="store-name"; inputName.value=store?store.name:"";
  tdName.appendChild(inputName);

  const tdShort=document.createElement("td");
  const inputShort=document.createElement("input");
  inputShort.type="text"; inputShort.maxLength=2; inputShort.className="store-short"; inputShort.value=store?(store.shortName||""):"";
  inputShort.addEventListener("input", ()=>refreshEmployeeStoreOptionsFromSettings());
  tdShort.appendChild(inputShort);

  const tdEnabled=document.createElement("td");
  const inputEnabled=document.createElement("input");
  inputEnabled.type="checkbox"; inputEnabled.className="store-enabled"; inputEnabled.checked=store?!!store.enabled:true;
  tdEnabled.appendChild(inputEnabled);

  const tdCodes=document.createElement("td");
  const wrap=document.createElement("div"); wrap.className="settings-inline-controls";
  workCodes.forEach(wc=>{
    const pill=document.createElement("span"); pill.className="pill";
    const codeLabel=document.createElement("span"); codeLabel.style.fontWeight="800"; codeLabel.textContent=wc.code;
    const dot=document.createElement("span"); dot.className="status-dot";
    pill.appendChild(codeLabel);
    pill.appendChild(dot);
    const sel=document.createElement("select"); sel.className="store-code-setting"; sel.dataset.code=wc.code;
    ["day","night","disabled"].forEach(mode=>{
      const opt=document.createElement("option");
      opt.value=mode;
      opt.textContent = mode==="day" ? "日勤" : mode==="night" ? "夜勤" : "無効";
      sel.appendChild(opt);
    });
    let initial="day";
    if(store){
      if(store.storeCodes && Array.isArray(store.storeCodes) && store.storeCodes.length>0){
        const sc=store.storeCodes.find(x=>x.code===wc.code);
        initial=sc ? (sc.type||"disabled") : "day";
      }else{
        initial="day";
      }
    }
    sel.value=initial;
    setStoreCodeDot(dot, initial);
    sel.addEventListener("change", ()=>setStoreCodeDot(dot, sel.value));
    pill.appendChild(sel);
    wrap.appendChild(pill);
  });
  tdCodes.appendChild(wrap);

  const tdDelete=document.createElement("td");
  const btnDel=document.createElement("button"); btnDel.className="btn-delete"; btnDel.textContent="削除";
  btnDel.addEventListener("click",()=>{
    const storeId=store?store.id:null;
    if(storeId && storeHasScheduleData(storeId)){
      alert("この店舗には勤務表データが存在するため削除できません。無効化してください。");
      return;
    }
    tr.remove();
    refreshEmployeeStoreOptionsFromSettings();
    refreshEmployeeOrderPanel();
    refreshEmployeeOrderPanel();
  });
  tdDelete.appendChild(btnDel);

  tr.appendChild(tdMove);
  tr.appendChild(tdName);
  tr.appendChild(tdShort);
  tr.appendChild(tdEnabled);
  tr.appendChild(tdCodes);
  tr.appendChild(tdDelete);

  dom.storeTableBody.appendChild(tr);
  // 追加直後でも従業員タブの所属店舗候補に反映する
  refreshEmployeeStoreOptionsFromSettings();
  refreshEmployeeStoreOptionsFromSettings();
}

function moveRow(tr, dir){
  const tbody=tr.parentElement;
  const rows=Array.from(tbody.children);
  const idx=rows.indexOf(tr);
  const newIdx=idx+dir;
  if(newIdx<0 || newIdx>=rows.length) return;
  if(dir<0) tbody.insertBefore(tr, rows[newIdx]);
  else tbody.insertBefore(rows[newIdx], tr);
}

function storeHasScheduleData(storeId){
  for(const ym of Object.keys(appState.schedules)){
    const sch=appState.schedules[ym];
    if(sch.byStore && sch.byStore[storeId]) return true;
  }
  return false;
}


function getSettingsStoresSorted(master){
  return (master.stores||[]).slice().sort((a,b)=>(a.order||0)-(b.order||0));
}
function fillEmployeeStoreSelect(selectEl, master, selectedId){
  const storesSorted=getSettingsStoresSorted(master);
  const enabledStores=storesSorted.filter(s=>s && s.enabled!==false);
  const current=selectedId?String(selectedId):"";
  selectEl.innerHTML="";
  const opt0=document.createElement("option");
  opt0.value=""; opt0.textContent="未所属";
  selectEl.appendChild(opt0);

  // enabled stores
  enabledStores.forEach(s=>{
    const opt=document.createElement("option");
    opt.value=String(s.id);
    opt.textContent=s.name;
    selectEl.appendChild(opt);
  });

  // if current points to disabled store, keep it visible but not selectable
  if(current && !enabledStores.some(s=>String(s.id)===current)){
    const ds=storesSorted.find(s=>String(s.id)===current);
    if(ds){
      const opt=document.createElement("option");
      opt.value=current;
      opt.textContent=(ds.name||"") + "（無効）";
      opt.disabled=true;
      selectEl.appendChild(opt);
    }
  }
  selectEl.value=current;
}
function refreshEmployeeStoreOptionsFromSettings(){
  // 設定モーダル内では「店舗タブの編集中DOM」を単一の真実として扱う（未保存追加も即反映）
  const stores = Array.from(dom.storeTableBody.querySelectorAll("tr")).map(tr=>{
    return {
      id: tr.dataset.id || "",
      name: (tr.querySelector(".store-name")?.value || "").trim(),
      shortName: (tr.querySelector(".store-short")?.value || "").trim(),
      enabled: !!tr.querySelector(".store-enabled")?.checked
    };
  });

  dom.employeeTableBody.querySelectorAll("select.emp-store").forEach(sel=>{
    const current = sel.value;
    sel.innerHTML = "";

    // 未所属
    const opt0=document.createElement("option");
    opt0.value="";
    opt0.textContent="（未所属）";
    sel.appendChild(opt0);

    // 有効店舗のみ選択肢にする
    stores.filter(s=>s.enabled).forEach(s=>{
      if(!s.id) return;
      const opt=document.createElement("option");
      opt.value = String(s.id);
      opt.textContent = s.name || s.shortName || `店舗${s.id}`;
      sel.appendChild(opt);
    });

    // 現在値が無効/存在しない場合：表示だけ残す（選択不可）で気づけるようにする
    if(current && !Array.from(sel.options).some(o=>o.value===current)){
      const s = stores.find(x=>String(x.id)===String(current));
      const opt=document.createElement("option");
      opt.value = String(current);
      opt.textContent = s ? `（無効）${s.name||s.shortName||current}` : `（未存在）${current}`;
      opt.disabled = true;
      sel.insertBefore(opt, sel.firstChild.nextSibling); // （未所属）の次
      sel.value = String(current);
    }else{
      sel.value = current || "";
    }
  });
}




function refreshEmployeeOrderPanel(){
  if(!dom.employeeOrderStoreSelect || !dom.employeeOrderList) return;

  // 店舗一覧（設定モーダル内DOM）
  const stores = Array.from(dom.storeTableBody.querySelectorAll("tr")).map(tr=>{
    return {
      id: tr.dataset.id || "",
      name: (tr.querySelector(".store-name")?.value || "").trim(),
      shortName: (tr.querySelector(".store-short")?.value || "").trim(),
      enabled: !!tr.querySelector(".store-enabled")?.checked
    };
  }).filter(s=>s.id);

  // セレクト更新（有効店舗 + 末尾に（未所属））
  const sel = dom.employeeOrderStoreSelect;
  const prev = sel.value;
  sel.innerHTML = "";

  stores.filter(s=>s.enabled).forEach(s=>{
    const opt=document.createElement("option");
    opt.value = String(s.id);
    opt.textContent = s.name || s.shortName || `店舗${s.id}`;
    sel.appendChild(opt);
  });

  // 末尾に（未所属）を追加（未所属従業員の確認用）
  {
    const opt=document.createElement("option");
    opt.value = "__none__";
    opt.textContent = "（未所属）";
    sel.appendChild(opt);
  }

  // 選択維持（なければ先頭）
  if(prev && Array.from(sel.options).some(o=>o.value===prev)) sel.value = prev;
  else if(sel.options.length>0) sel.value = sel.options[0].value;

  const storeId = sel.value || "";

  // 従業員（設定モーダル内DOM）
  const employees = Array.from(dom.employeeTableBody.querySelectorAll("tr")).map(tr=>{
    const id = tr.dataset.id || "";
    const last = (tr.querySelector(".emp-last")?.value || "").trim();
    const first = (tr.querySelector(".emp-first")?.value || "").trim();
    const store = (tr.querySelector("select.emp-store")?.value || "");
    const order = Number(tr.querySelector(".emp-order")?.value || "0") || 0;
    return {id,last,first,storeId:store,order};
  });

  const list = dom.employeeOrderList;
  list.innerHTML = "";

  if(!storeId && storeId!=="__none__"){
    const empty=document.createElement("div");
    empty.className="text-muted";
    empty.style.fontSize="12px";
    empty.textContent="店舗がありません（店舗タブで追加してください）";
    list.appendChild(empty);
    return;
  }

  const storeName = (storeId==="__none__")
    ? "（未所属）"
    : ((stores.find(s=>String(s.id)===String(storeId))?.name) || "");
  const items = employees
    .filter(e=>{
      if(String(storeId)==="__none__") return !String(e.storeId||"");
      return String(e.storeId||"")===String(storeId);
    })
    .sort((a,b)=> (a.order||0)-(b.order||0) || (a.last+a.first).localeCompare(b.last+b.first,'ja'));

  // DnD用：空でもドロップできるようにゾーンを描画
  const dropzone=document.createElement("div");
  dropzone.className="employee-order-dropzone";
  dropzone.dataset.storeId = String(storeId);
  list.appendChild(dropzone);

  if(items.length===0){
    const empty=document.createElement("div");
    empty.className="text-muted";
    empty.style.fontSize="12px";
    empty.textContent = storeName ? `${storeName} に所属する従業員がいません（左からドラッグで追加）` : "所属する従業員がいません";
    dropzone.appendChild(empty);
    // ワイヤリング（空でも受け取る）
    ensureEmployeeOrderDnDInitialized();
    return;
  }

  items.forEach((e,idx)=>{
    const row=document.createElement("div");
    row.className="employee-order-item";
    row.draggable = true;
    row.dataset.empId = String(e.id);
    row.dataset.storeId = String(storeId);

    const left=document.createElement("div");
    left.style.display="flex";
    left.style.alignItems="center";
    left.style.gap="10px";

    const handle=document.createElement("div");
    handle.className="drag-handle";
    handle.title="ドラッグで並び替え / 左からドラッグで追加";
    handle.innerHTML = "⋮⋮";

    const name=document.createElement("div");
    name.innerHTML = `<div class="name">${escapeHtml(e.last)}${e.first?(" "+escapeHtml(e.first)):""}</div><div class="meta">順番: ${e.order||0}</div>`;

    left.appendChild(handle);
    left.appendChild(name);

    const right=document.createElement("div");
    right.className="text-muted";
    right.style.fontSize="11px";
    right.textContent = "ドラッグで並び替え";

    row.appendChild(left);
    row.appendChild(right);
    dropzone.appendChild(row);
  });

  // ワイヤリング（描画のたびに必要だが多重登録は防ぐ）
  ensureEmployeeOrderDnDInitialized();
}


// ===== 従業員：店舗別ドラッグ＆ドロップ並び替え（設定モーダル内） =====
let __empDnD = null;
function ensureEmployeeOrderDnDInitialized(){
  if(__empDnD) return;
  __empDnD = {
    active:false,
    from:null,        // "left" | "right"
    empId:null,
    fromStoreId:null,
    placeholder:null,
    placeholderIndex:null
  };

  // ===== drag UX helpers =====
  function setDraggingUi(isOn){
    // NOTE: ネイティブDnD中はCSS cursorが効きにくいことがあるため
    // dropEffect と併用する。
    try{
      document.documentElement.classList.toggle("is-dragging", !!isOn);
    }catch(_e){}
    try{
      // 右側のドロップ先を視覚的に示す（CSS: .drop-allowed）
      dom.employeeOrderList?.classList.toggle("drop-allowed", !!isOn);
      dom.employeeOrderList?.querySelector(".employee-order-dropzone")?.classList.toggle("drop-allowed", !!isOn);
    }catch(_e){}
  }

  function isInEmployeeOrderArea(target){
    if(!target) return false;
    try{
      return !!(target.closest && target.closest("#employeeOrderList, .employee-order-dropzone, .employee-order-item, .employee-order-placeholder"));
    }catch(_e){ return false; }
  }

  function setDropOver(isOver){
    try{
      const dz = dom.employeeOrderList?.querySelector(".employee-order-dropzone");
      if(!dz) return;
      dz.classList.toggle("drop-over", !!isOver);
      dom.employeeOrderList.classList.toggle("drop-over", !!isOver);
    }catch(_e){}
  }

  // 左テーブル：行ドラッグ開始
  dom.employeeTableBody.addEventListener("dragstart", (ev)=>{
    const tr = ev.target && ev.target.closest ? ev.target.closest("tr[data-id]") : null;
    if(!tr) return;

    // v201: 行のどこからでもドラッグ開始OK（ただし入力・ボタン等のコントロール上は除外）
    const interactive = ev.target && ev.target.closest ? ev.target.closest("input,select,textarea,button,a,label") : null;
    if(interactive){
      // コントロールの操作（選択/クリック）を邪魔しない
      ev.preventDefault();
      return;
    }

    const empId = tr.dataset.id;

    __empDnD.active = true;
    __empDnD.from = "left";
    __empDnD.empId = String(empId);
    __empDnD.fromStoreId = (tr.querySelector("select.emp-store")?.value || "") || "";
    __empDnD.placeholderIndex = null;

    setDraggingUi(true);
    setDropOver(false);

    try{
      ev.dataTransfer.effectAllowed = "move";
      ev.dataTransfer.setData("text/plain", JSON.stringify({type:"emp", id:String(empId), from:"left"}));
      try{ ev.dataTransfer.setData("text/uri-list",""); }catch(_e){}
    }catch(_e){}
    logSettingsDnD(`ドラッグ開始（左）: ${String(empId)}`);
  }, true);

  dom.employeeTableBody.addEventListener("dragend", ()=>{
    cleanupEmpDnDVisual();
  }, true);

  // 右側：captureで必ずdragover/dropを受ける
  
  // --- (v125) DOM再描画で employeeOrderList が差し替わってもDnDが動くように、document委譲を入れる ---
  if(!window.__empDnDDelegationInstalled){
    window.__empDnDDelegationInstalled = true;

    document.addEventListener("dragover", (ev)=>{
      const list = ev.target && ev.target.closest ? ev.target.closest("#employeeOrderList") : null;
      if(!list) return;
      // 二重実行防止（下位のリスナーを止める）
      ev.stopPropagation();
      if(ev.stopImmediatePropagation) ev.stopImmediatePropagation();
          if(!__empDnD.active) return;
          ev.preventDefault();
          ev.stopPropagation();
          if(ev.stopImmediatePropagation) ev.stopImmediatePropagation();
          updateEmpDnDPlaceholder(ev.clientY);
          // v117: placeholderが出ている時だけ move を表示
          if(ev.dataTransfer){
            const hasPlaceholder = !!(__empDnD.placeholder && __empDnD.placeholder.isConnected);
            ev.dataTransfer.dropEffect = hasPlaceholder ? "move" : "none";
          }
          setDropOver(true);
    }, true);

    document.addEventListener("drop", (ev)=>{
      const list = ev.target && ev.target.closest ? ev.target.closest("#employeeOrderList") : null;
      if(!list) return;
      // 二重実行防止（下位のリスナーを止める）
      ev.stopPropagation();
      if(ev.stopImmediatePropagation) ev.stopImmediatePropagation();
          // 右側ドロップ（左→右、右→右、店舗間移動）
          try{
            console.debug("[settings-dnd] drop(candidate)", {
              active: __empDnD.active,
              targetTag: ev.target?.tagName,
              targetCls: ev.target?.className,
              targetId: ev.target?.id,
              empId: __empDnD.empId,
              from: __empDnD.from,
              fromStoreId: __empDnD.fromStoreId,
              storeSelect: dom.employeeOrderStoreSelect?.value || "",
              placeholderIndex: __empDnD.placeholderIndex
            });
          }catch(_e){}
      
          if(!__empDnD.active) return;
      
          // drop を受け付ける
          ev.preventDefault();
      
          const payload = readEmpDnDPayload(ev);
          if(!payload || payload.type!=="emp"){
            try{ console.debug("[settings-dnd] drop: no payload"); }catch(_e){}
            cleanupEmpDnDVisual();
            return;
          }
      
          // ドロップ先店舗：基本はセレクト。dropzoneにdatasetがあればそれを優先（将来の拡張・保険）
          let storeId = dom.employeeOrderStoreSelect?.value || "";
          const dz = ev.target && ev.target.closest ? ev.target.closest(".employee-order-dropzone[data-store-id]") : null;
          if(dz && dz.dataset && dz.dataset.storeId) storeId = String(dz.dataset.storeId);
      
          if(!storeId){
            try{ console.debug("[settings-dnd] drop: storeId empty"); }catch(_e){}
            cleanupEmpDnDVisual();
            return;
          }
      
          const targetIndex = computeEmpDnDPlaceholderIndex();
          try{
            console.debug("[settings-dnd] drop: apply", {empId: payload.id, storeId, targetIndex});
          }catch(_e){}
      
          applyEmpDnDDrop(payload, storeId, targetIndex);
      
          cleanupEmpDnDVisual();
          try{ if(typeof refreshEmployeeStoreOptionsFromSettings==='function') refreshEmployeeStoreOptionsFromSettings(); }catch(_e){}
          try{ if(typeof refreshEmployeeOrderPanel==='function') refreshEmployeeOrderPanel(); }catch(_e){}
    }, true);
  }
dom.employeeOrderList.addEventListener("dragover", (ev)=>{
    if(!__empDnD.active) return;
    ev.preventDefault();
    ev.stopPropagation();
    if(ev.stopImmediatePropagation) ev.stopImmediatePropagation();
    updateEmpDnDPlaceholder(ev.clientY);
    // v117: placeholderが出ている時だけ move を表示
    if(ev.dataTransfer){
      const hasPlaceholder = !!(__empDnD.placeholder && __empDnD.placeholder.isConnected);
      ev.dataTransfer.dropEffect = hasPlaceholder ? "move" : "none";
    }
    setDropOver(true);
  }, true);

  dom.employeeOrderList.addEventListener("drop", (ev)=>{
    // 右側ドロップ（左→右、右→右、店舗間移動）
    try{
      console.debug("[settings-dnd] drop(candidate)", {
        active: __empDnD.active,
        targetTag: ev.target?.tagName,
        targetCls: ev.target?.className,
        targetId: ev.target?.id,
        empId: __empDnD.empId,
        from: __empDnD.from,
        fromStoreId: __empDnD.fromStoreId,
        storeSelect: dom.employeeOrderStoreSelect?.value || "",
        placeholderIndex: __empDnD.placeholderIndex
      });
    }catch(_e){}

    if(!__empDnD.active) return;

    // drop を受け付ける
    ev.preventDefault();

    const payload = readEmpDnDPayload(ev);
    if(!payload || payload.type!=="emp"){
      try{ console.debug("[settings-dnd] drop: no payload"); }catch(_e){}
      cleanupEmpDnDVisual();
      return;
    }

    // ドロップ先店舗：基本はセレクト。dropzoneにdatasetがあればそれを優先（将来の拡張・保険）
    let storeId = dom.employeeOrderStoreSelect?.value || "";
    const dz = ev.target && ev.target.closest ? ev.target.closest(".employee-order-dropzone[data-store-id]") : null;
    if(dz && dz.dataset && dz.dataset.storeId) storeId = String(dz.dataset.storeId);

    if(!storeId){
      try{ console.debug("[settings-dnd] drop: storeId empty"); }catch(_e){}
      cleanupEmpDnDVisual();
      return;
    }

    const targetIndex = computeEmpDnDPlaceholderIndex();
    try{
      console.debug("[settings-dnd] drop: apply", {empId: payload.id, storeId, targetIndex});
    }catch(_e){}

    applyEmpDnDDrop(payload, storeId, targetIndex);

    cleanupEmpDnDVisual();
    try{ if(typeof refreshEmployeeStoreOptionsFromSettings==='function') refreshEmployeeStoreOptionsFromSettings(); }catch(_e){}
    try{ if(typeof refreshEmployeeOrderPanel==='function') refreshEmployeeOrderPanel(); }catch(_e){}
  }, true);

  // 右側：並び替えのdragstart/dragend（委譲）
  dom.employeeOrderList.addEventListener("dragstart", (ev)=>{
    const item = ev.target && ev.target.closest ? ev.target.closest(".employee-order-item[data-emp-id]") : null;
    if(!item) return;
    const empId = item.dataset.empId;
    const storeId = item.dataset.storeId || (dom.employeeOrderStoreSelect?.value||"");
    __empDnD.active = true;
    __empDnD.from = "right";
    __empDnD.empId = String(empId);
    __empDnD.fromStoreId = String(storeId);
    __empDnD.placeholderIndex = null;

    setDraggingUi(true);
    setDropOver(false);

    item.classList.add("dragging-row");

    try{
      ev.dataTransfer.effectAllowed = "move";
      ev.dataTransfer.setData("text/plain", JSON.stringify({type:"emp", id:String(empId), from:"right", storeId:String(storeId)}));
      try{ ev.dataTransfer.setData("text/uri-list",""); }catch(_e){}
    }catch(_e){}
    ensureEmpDnDPlaceholder();
    logSettingsDnD(`ドラッグ開始（右）: ${String(empId)} / store=${String(storeId)}`);
  }, true);

  dom.employeeOrderList.addEventListener("dragend", ()=>{
    cleanupEmpDnDVisual();
  }, true);

  // ページ遷移/ファイルオープン防止
  // 重要: document 全体で dragover を preventDefault すると「どこでもドロップ可能」と見なされ、
  // 禁止カーソル（not-allowed）が出なくなる。
  // → ドロップ先（右パネル）のみ preventDefault。
  document.addEventListener("dragover", (ev)=>{
    if(!__empDnD.active) return;
    // ドロップ不可の場所では何もしない（ブラウザの not-allowed 表示に任せる）
    const ok = isInEmployeeOrderArea(ev.target);
    if(!ok){
      try{ if(ev.dataTransfer) ev.dataTransfer.dropEffect = "none"; }catch(_e){}
      setDropOver(false);
      return;
    }
    // 右パネル内でも、placeholderが出ない状況（=ドロップ不可能）は none
    try{
      const hasPlaceholder = !!(__empDnD.placeholder && __empDnD.placeholder.isConnected);
      if(ev.dataTransfer) ev.dataTransfer.dropEffect = hasPlaceholder ? "move" : "none";
    }catch(_e){}
  }, true);

  document.addEventListener("drop", (ev)=>{
    if(!__empDnD.active) return;
    // どこで落としてもファイルが開かないようにする（dragover は触らない）
    ev.preventDefault();
    ev.stopPropagation();
    setDropOver(false);
    cleanupEmpDnDVisual();
  }, true);

  function logSettingsDnD(msg){
    try{
      if(typeof log==='function') { log(msg); return; }
    }catch(_e){}
    try{ console.debug(`[settings-dnd] ${msg}`); }catch(_e){}
  }

  function readEmpDnDPayload(ev){
    // v103以前の互換：内部状態優先
    if(__empDnD.empId){
      return {type:"emp", id:String(__empDnD.empId), from: __empDnD.from, storeId: __empDnD.fromStoreId};
    }
    try{
      const t = ev.dataTransfer?.getData("text/plain") || "";
      if(!t) return null;
      return JSON.parse(t);
    }catch(_e){ return null; }
  }

  function ensureEmpDnDPlaceholder(){
    if(__empDnD.placeholder && __empDnD.placeholder.isConnected) return;
    const ph = document.createElement("div");
    ph.className = "employee-order-placeholder";
    ph.textContent = "ここに挿入";
    __empDnD.placeholder = ph;
  }

  function getCurrentOrderIds(storeId){
    const items = Array.from(dom.employeeOrderList.querySelectorAll('.employee-order-item[data-store-id="'+String(storeId)+'"][data-emp-id]'));
    return items.map(el=>String(el.dataset.empId));
  }

  function updateEmpDnDPlaceholder(clientY){
    ensureEmpDnDPlaceholder();
    const storeId = dom.employeeOrderStoreSelect?.value || "";
    if(!storeId) return;

    const dropzone = dom.employeeOrderList.querySelector(".employee-order-dropzone");
    if(!dropzone) return;

    const rows = Array.from(dropzone.querySelectorAll(".employee-order-item[data-emp-id]"))
      .filter(el=>!el.classList.contains("dragging-row"));

    // 空リストは末尾
    if(rows.length===0){
      if(__empDnD.placeholder.parentNode!==dropzone) dropzone.appendChild(__empDnD.placeholder);
      __empDnD.placeholderIndex = 0;
      return;
    }

    let insertIndex = rows.length;
    for(let i=0;i<rows.length;i++){
      const r = rows[i];
      const rect = r.getBoundingClientRect();
      const mid = rect.top + rect.height/2;
      if(clientY < mid){
        insertIndex = i;
        break;
      }
    }
    __empDnD.placeholderIndex = insertIndex;

    // DOMへ反映
    if(insertIndex>=rows.length){
      dropzone.appendChild(__empDnD.placeholder);
    }else{
      dropzone.insertBefore(__empDnD.placeholder, rows[insertIndex]);
    }
  }

  function computeEmpDnDPlaceholderIndex(){
    const idx = __empDnD.placeholderIndex;
    if(idx==null) return null;
    return idx;
  }

  function applyEmpDnDDrop(payload, storeId, targetIndex){
    const empId = String(payload.id);
    const ids = getCurrentOrderIds(storeId);

    // 右→右：同一店舗内の移動
    const fromSameStore = (payload.from==="right" && String(payload.storeId||"")===String(storeId));
    let list = ids.slice();

    // 左→右、または別店舗へ移動する場合は所属店舗を更新する（右リストは所属店舗で表示を決める）
    if(!fromSameStore){
      try{ setEmployeeStore(empId, storeId); }catch(_e){}
      // 元店舗の並び順も詰め直す（見た目とデータの不整合防止）
      try{
        const fromStore = String(payload.storeId||"");
        if(fromStore && fromStore!==String(storeId)){
          const fromIds = getCurrentOrderIds(fromStore).filter(id=>String(id)!==empId);
          fromIds.forEach((id,i)=>{ setEmployeeOrder(String(id),(i+1)*10); });
        }
      }catch(_e){}
    }


    // まずドラッグ対象がリスト内にいるなら取り除く
    const curPos = list.indexOf(empId);
    if(curPos>=0) list.splice(curPos,1);

    // 左→右 or 他店舗→右：この店舗へ所属変更
    setEmployeeStore(empId, storeId);

    // 挿入位置
    let idx = (typeof targetIndex==="number" && targetIndex>=0) ? targetIndex : list.length;
    if(idx>list.length) idx=list.length;
    list.splice(idx,0,empId);

    // order採番（10刻み）
    list.forEach((id, i)=>{
      setEmployeeOrder(id, (i+1)*10);
    });

    // v120: DnD後に右パネルが更新されない問題を修正（所属/並び替え反映）
    try{ if(typeof markDirty==='function') markDirty(); }catch(_e){}
    // refreshEmployeeOrderPanel は drop ハンドラ側で1回だけ呼ぶ

    // 同一店舗の他従業員の順番も確実に更新（表の入力値を単一真実に）
    // ※ listに含まれないが同店舗扱いのものがある場合（無効店舗等）への保険
    dom.employeeTableBody.querySelectorAll("tr[data-id]").forEach(tr=>{
      const id = String(tr.dataset.id||"");
      const sel = tr.querySelector("select.emp-store");
      if(!sel) return;
      if(String(sel.value||"")===String(storeId)){
        const ord = Number(tr.querySelector(".emp-order")?.value||"0")||0;
        // listにないものは末尾へ
        if(!list.includes(id)){
          setEmployeeOrder(id, (list.length+1)*10);
          list.push(id);
        }
      }
    });
  }

  function setEmployeeStore(empId, storeId){
    const tr = dom.employeeTableBody.querySelector('tr[data-id="'+String(empId)+'"]');
    if(!tr) return;
    const sel = tr.querySelector("select.emp-store");
    if(sel){
      sel.value = String(storeId);
      // changeイベントを起こして未保存判定を正しくする（既存実装に合わせる）
      sel.dispatchEvent(new Event("change", {bubbles:true}));
    }
  }

  function setEmployeeOrder(empId, order){
    const tr = dom.employeeTableBody.querySelector('tr[data-id="'+String(empId)+'"]');
    if(!tr) return;
    const input = tr.querySelector(".emp-order");
    if(input){
      // order は内部(10刻み)。表示は 1刻みなので /10。
      input.value = String(Math.round((Number(order)||0)/10));input.dispatchEvent(new Event("input", {bubbles:true}));
      input.dispatchEvent(new Event("change", {bubbles:true}));
    }
  }

  function cleanupEmpDnDVisual(){
    __empDnD.active = false;
    __empDnD.from = null;
    __empDnD.empId = null;
    __empDnD.fromStoreId = null;
    __empDnD.placeholderIndex = null;

    document.querySelectorAll(".dragging-row").forEach(el=>el.classList.remove("dragging-row"));
    if(__empDnD.placeholder && __empDnD.placeholder.parentNode){
      __empDnD.placeholder.parentNode.removeChild(__empDnD.placeholder);
    }
    setDropOver(false);
    setDraggingUi(false);
  }
}




function addEmployeeRow(emp){
  const master=getSettingsMasterTarget() || appState.templateMaster;
  const tr=document.createElement("tr");
  tr.dataset.id = emp ? emp.id : "";
  // Safari/Chromium系で td.draggable だけだと dragstart が発火しないケースがあるため、
  // 行(tr)自体も draggable にしておく（ただし開始判定はハンドル列で絞る）。
  tr.draggable = true;

  // DnD handle (left -> right: assign to store / move)
  const tdHandle=document.createElement("td");
  tdHandle.className="emp-drag-cell";
  const handle=document.createElement("span");
  handle.className="emp-drag-handle";
  handle.textContent="⋮⋮";
  handle.title="ドラッグで店舗に追加 / 移動";
  tdHandle.title="ドラッグで店舗に追加 / 移動";
  // 実際のドラッグ対象は tr だが、UX的にハンドル列も draggable にしておく
  tdHandle.draggable = true;
  // 新規作成時(empが未指定)は id が無いので空文字にする（ここで例外が出ると追加できなくなる）
  tdHandle.dataset.empId = emp ? emp.id : "";
  // ハンドル自体でもドラッグ開始できるようにする
  handle.draggable = true;
  tdHandle.appendChild(handle);

  const tdLast=document.createElement("td");
  const inputLast=document.createElement("input");
  inputLast.type="text"; inputLast.className="emp-last"; inputLast.value=emp?emp.lastName:"";
  tdLast.appendChild(inputLast);
  // 左の編集（姓）を右パネルへ即反映
  inputLast.addEventListener("input", ()=>{ refreshEmployeeOrderPanel(); });
  inputLast.addEventListener("change", ()=>{ refreshEmployeeOrderPanel(); });

  tr.appendChild(tdHandle);

  const tdFirst=document.createElement("td");
  const inputFirst=document.createElement("input");
  inputFirst.type="text"; inputFirst.className="emp-first"; inputFirst.value=emp?emp.firstName:"";
  tdFirst.appendChild(inputFirst);
  // 左の編集（名）を右パネルへ即反映
  inputFirst.addEventListener("input", ()=>{ refreshEmployeeOrderPanel(); });
  inputFirst.addEventListener("change", ()=>{ refreshEmployeeOrderPanel(); });

  const tdStore=document.createElement("td");
  const selectStore=document.createElement("select"); selectStore.className="emp-store";
  selectStore.addEventListener("change", ()=>{ refreshEmployeeOrderPanel(); });
  const optNone=document.createElement("option"); optNone.value=""; optNone.textContent="(未所属)";
  selectStore.appendChild(optNone);
    // 店舗候補は設定モーダル内の店舗タブDOM（未保存追加を含む）から都度反映する
  // （ここでは最低限の選択肢だけ作り、後で refreshEmployeeStoreOptionsFromSettings() で埋める）
  if(emp && emp.storeId) selectStore.value=String(emp.storeId);
  tdStore.appendChild(selectStore);

  const tdOrder=document.createElement("td");
  const inputOrder=document.createElement("input");
  inputOrder.type="number";
  inputOrder.className="emp-order";
  inputOrder.readOnly = true;
  inputOrder.tabIndex = -1;
  // 内部は10刻みだが、ユーザー表示は1刻み（表示=内部/10）。入力は不要なのでreadonly。
  inputOrder.value = emp && Number.isFinite(emp.orderInStore) ? String(Math.round((emp.orderInStore||0)/10)) : "";
  tdOrder.appendChild(inputOrder);
  // 左の編集（店舗内順）を右パネルへ即反映
  inputOrder.addEventListener("input", ()=>{ refreshEmployeeOrderPanel(); });
  inputOrder.addEventListener("change", ()=>{ refreshEmployeeOrderPanel(); });

  const tdDelete=document.createElement("td");
  const btnDel=document.createElement("button"); btnDel.className="btn-delete"; btnDel.textContent="削除";
  btnDel.addEventListener("click",()=>{
    const empId=emp?emp.id:null;
    if(empId && employeeHasScheduleData(empId)){
      alert("この従業員には勤務表データが存在するため削除できません。所属店舗を未所属にしてください。");
      return;
    }
    tr.remove();
    refreshEmployeeStoreOptionsFromSettings();
    refreshEmployeeOrderPanel();
  });
  tdDelete.appendChild(btnDel);

  tr.appendChild(tdLast); tr.appendChild(tdFirst); tr.appendChild(tdStore); tr.appendChild(tdOrder); tr.appendChild(tdDelete);
  dom.employeeTableBody.appendChild(tr);
  // 店舗タブの編集内容（未保存店舗追加/無効化など）を即反映
  refreshEmployeeStoreOptionsFromSettings();
  refreshEmployeeOrderPanel();
}

function employeeHasScheduleData(empId){
  for(const ym of Object.keys(appState.schedules)){
    const sch=appState.schedules[ym];
    for(const storeIdStr of Object.keys(sch.byStore||{})){
      const storeData=sch.byStore[Number(storeIdStr)];
      const rec=storeData.assignments?.[empId];
      if(!rec) continue;
      if((rec.main||[]).some(Boolean) || (rec.note||[]).some(Boolean)) return true;
    }
  }
  return false;
}

function addLeaveCodeRow(lc){
  const tr=document.createElement("tr");
  const tdCode=document.createElement("td");
  const inputCode=document.createElement("input");
  inputCode.type="text"; inputCode.className="leave-code"; inputCode.value=lc?lc.code:"";
  tdCode.appendChild(inputCode);

  const tdKey=document.createElement("td");
  const inputKey=document.createElement("input");
  inputKey.type="number"; inputKey.min="0"; inputKey.max="9"; inputKey.className="leave-key"; inputKey.value=lc?(lc.key||""):"";
  tdKey.appendChild(inputKey);

  const tdDel=document.createElement("td");
  const btnDel=document.createElement("button");
  btnDel.className = "btn-delete"; // 休暇コードタブも従業員タブと同じ削除ボタンスタイルに揃える
  btnDel.textContent="削除";
  btnDel.addEventListener("click",()=>tr.remove());
  tdDel.appendChild(btnDel);

  tr.appendChild(tdCode); tr.appendChild(tdKey); tr.appendChild(tdDel);
  dom.leaveCodeTableBody.appendChild(tr);
}

function refreshAfterMasterChange(){
  renderStoreOptions();
  renderSupportStoreOptions();
  renderKeypad();
  renderSchedule();
}

function reconcileScheduleDataWithSnapshot(schedule){
  const snapshot=schedule.masterSnapshot;
  const daysInMonth=getDaysInMonth(schedule.year, schedule.month);

  // 1) byStore の存在を保証（有効店舗 + 従業員が所属している店舗）
  const storeIds = new Set();
  snapshot.stores.forEach(s=>storeIds.add(s.id));
  snapshot.employees.forEach(e=>{ if(e.storeId) storeIds.add(e.storeId); });

  for(const storeId of storeIds){
    if(!schedule.byStore[storeId]){
      schedule.byStore[storeId]={assignments:{}};
    }
  }

  // 2) 従業員の所属変更・追加：assignments を移動/作成
  // まず現状の配置を収集
  const currentEmpStore = new Map(); // empId -> storeId
  for(const [storeIdStr, storeData] of Object.entries(schedule.byStore)){
    const storeId=Number(storeIdStr);
    for(const empIdStr of Object.keys(storeData.assignments||{})){
      currentEmpStore.set(Number(empIdStr), storeId);
    }
  }

  snapshot.employees.forEach(emp=>{
    const empId=emp.id;
    const targetStoreId=emp.storeId || null;

    const existingStoreId = currentEmpStore.has(empId) ? currentEmpStore.get(empId) : null;

    if(targetStoreId){
      // 移動 or 新規
      if(existingStoreId && existingStoreId!==targetStoreId){
        const from = schedule.byStore[existingStoreId];
        const to = schedule.byStore[targetStoreId] || (schedule.byStore[targetStoreId]={assignments:{}});
        to.assignments[empId] = from.assignments[empId];
        delete from.assignments[empId];
      }else if(!existingStoreId){
        const to = schedule.byStore[targetStoreId] || (schedule.byStore[targetStoreId]={assignments:{}});
        to.assignments[empId] = { main:new Array(daysInMonth).fill(""), note:new Array(daysInMonth).fill("") };
      }
      // 配列長の補正
      const rec = schedule.byStore[targetStoreId].assignments[empId];
      if(rec){
        if(!Array.isArray(rec.main)) rec.main=[];
        if(!Array.isArray(rec.note)) rec.note=[];
        rec.main.length = daysInMonth; rec.note.length = daysInMonth;
        for(let i=0;i<daysInMonth;i++){
          if(rec.main[i]===undefined) rec.main[i] = "";
          if(rec.note[i]===undefined) rec.note[i] = "";
        }
      }
    }else{
      // 未所属にした：assignments は残しても良いが、表示対象外になる
      // ただし、既存の assignments が別店舗に残っていればそのまま保持（データ保護）
    }
  });

  // 3) snapshotから削除された従業員：データが空なら assignments から消す、空でなければ保持（表示されないなら storeId=null を推奨）
  const snapshotEmpIds = new Set(snapshot.employees.map(e=>e.id));
  for(const [storeIdStr, storeData] of Object.entries(schedule.byStore)){
    for(const empIdStr of Object.keys(storeData.assignments||{})){
      const empId=Number(empIdStr);
      if(snapshotEmpIds.has(empId)) continue;
      const rec=storeData.assignments[empId];
      const hasData = (rec?.main||[]).some(v=>v) || (rec?.note||[]).some(v=>v);
      if(!hasData){
        delete storeData.assignments[empId];
      }
    }
  }

  persistState();
}

/* ===== Printing ===== */
function getStoreIdsInSchedule(schedule){
  const stores=schedule.masterSnapshot.stores.slice().sort((a,b)=>(a.order||0)-(b.order||0));
  const ids=[];
  stores.forEach(s=>{ if(schedule.byStore[s.id]) ids.push(s.id); });
  return ids;
}

function openPrintWindowForMonth(schedule, storeIds){
  const html=buildPrintHtml(schedule, storeIds);
  const w=window.open("", "_blank");
  if(!w){ alert("ポップアップがブロックされています。Edgeの設定で許可してください。"); return; }
  w.document.open();
  w.document.write(html);
  w.document.close();
  w.focus();
  setTimeout(()=>w.print(), 250);
}

function buildPrintHtml(schedule, storeIds){
  const {year,month}=schedule;
  const wk=toWareki(year,month);
  const daysInMonth=getDaysInMonth(year,month);
  const weekDays=["日","月","火","水","木","金","土"];

  const style = `
    <style>
      @page{size:A4 landscape;margin:8mm}
      body{font-family:system-ui,-apple-system,"Segoe UI","Yu Gothic UI","Meiryo",sans-serif;color:#111827}
      .page{page-break-after:always}
      .page:last-child{page-break-after:auto}
      .title{text-align:center;font-size:12.5pt;font-weight:800;letter-spacing:.06em;margin:0 0 6mm}
      .subtitle{text-align:center;font-size:11pt;font-weight:700;margin:-4mm 0 6mm;color:#374151}
      table{border-collapse:collapse;width:100%;table-layout:fixed}
      th,td{border:1px solid #d1d5db;text-align:center;padding:2mm 1mm;font-size:8.6pt}
      thead th{background:#f3f4f6;font-weight:800}
      .weekday{font-size:8pt;color:#6b7280;font-weight:800}
      .sun{color:#d32f2f}.sat{color:#1976d2}
      .namecol{width:24mm;font-weight:800}
      .noteRow td{border-top-style:dashed;border-top-color:#9ca3af}
      .supportHead{background:#f9fafb;font-weight:800}
      .supportRow td{background:#fafafa}
      .supportFirst th,.supportFirst td{border-top:3px double #6b7280}
      .small{font-size:8pt;color:#6b7280;margin-top:2mm}
    
/* v107 layout fix */
.employee-settings-container{
  display: grid;
  grid-template-columns: minmax(420px, 520px) 1fr;
  gap: 16px;
  align-items: stretch;
}
.employee-left{
  max-width: 520px;
  overflow-x: auto;
}
.employee-right{
  min-width: 0;
}


/* v128+: left drag handle = 6-dot grip (no icon in column header) */
.employee-table-fixed td.emp-drag-cell{
  position:relative;
  user-select:none;
  text-align:center;
}
.employee-table-fixed .employee-table-fixed td.emp-drag-cell::before{
  content:"";
  position:absolute;
  left:50%;
  top:50%;
  width:14px;
  height:18px;
  transform:translate(-50%,-50%);
  background:
    radial-gradient(circle, rgba(107,114,128,.95) 1.2px, transparent 1.3px) 0 0 / 6px 6px,
    radial-gradient(circle, rgba(107,114,128,.95) 1.2px, transparent 1.3px) 3px 3px / 6px 6px;
  pointer-events:none;
  opacity:1;
}
/* span is kept for accessibility / grab cursor; visual is on the cell */
.employee-table-fixed td.emp-drag-cell .emp-drag-handle{
  /* v160: match row control height and keep icon centered */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: 32px;  /* matches input/select/button height (v158) */
  line-height: 1;
  cursor: grab;
}
.employee-table-fixed th:nth-child(1),
.employee-table-fixed td:nth-child(1){
  border-right-color: transparent;
}
.employee-table-fixed th:nth-child(2),
.employee-table-fixed td:nth-child(2){
  border-left-color: transparent;
}
}



/* v150: hard lock drag column to 28px */

#settingsEmployees table.settings-table.employee-table-fixed{
  table-layout: fixed !important;
}

/* 1列目 col を直接ロック（class を付与） */
#settingsEmployees table.settings-table.employee-table-fixed col.drag-col{
  width: 28px !important;
  min-width: 28px !important;
  max-width: 28px !important;
}

/* ヘッダ/セルも class でロック（列がズレても効く） */
#settingsEmployees table.settings-table.employee-table-fixed th.employee-drag-handle,
#settingsEmployees table.settings-table.employee-table-fixed td.emp-drag-cell{
  width: 28px !important;
  min-width: 28px !important;
  max-width: 28px !important;

  padding-left: 0 !important;
  padding-right: 0 !important;
  box-sizing: border-box !important;
  overflow: hidden !important;

  /* 何かが flex に変えても列幅計算を壊さない */
  display: table-cell !important;
}

/* flex レイアウトに巻き込まれた場合の保険（table外で使われた時も） */
#settingsEmployees table.settings-table.employee-table-fixed th.employee-drag-handle,
#settingsEmployees table.settings-table.employee-table-fixed td.emp-drag-cell{
  flex: 0 0 28px !important;
}

/* 見た目：セル内のハンドルを中央寄せ */
#settingsEmployees table.settings-table.employee-table-fixed td.emp-drag-cell .emp-drag-handle,
#settingsEmployees table.settings-table.employee-table-fixed th.employee-drag-handle .emp-drag-handle{
  /* v160: match row control height and keep icon centered */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: 32px;  /* matches input/select/button height (v158) */
  line-height: 1;
  cursor: grab;
}




/* v162: force thead row/cell height to match body row controls */
#settingsEmployees table.employee-table-fixed thead tr{
  height: 32px !important;      /* table row height works more reliably than cell pseudo content */
}
#settingsEmployees table.employee-table-fixed thead th{
  height: 32px !important;
  vertical-align: middle !important;
}
#settingsEmployees table.employee-table-fixed thead th.employee-drag-handle{
  padding: 0 !important;
}
/* keep the header drag cell from collapsing when empty */
#settingsEmployees table.employee-table-fixed thead th.employee-drag-handle{
  min-width: 28px !important;
}


/* v164: make header drag-handle cell match other header cell height (padding-driven) */
#settingsEmployees table.employee-table-fixed thead th.employee-drag-handle{
  /* other header cells use padding: 6px 10px; match vertical padding but keep horizontal tight */
  padding-top: 6px !important;
  padding-bottom: 6px !important;
  padding-left: 0 !important;
  padding-right: 0 !important;
  line-height: normal !important;
  vertical-align: middle !important;
}


/* v165: header drag cell should behave like other header cells (height/padding) */
#settingsEmployees table.employee-table-fixed thead th.employee-drag-handle{
  display: table-cell !important;
  padding: 6px 8px !important;   /* match .employee-table-fixed th,td default */
  cursor: default !important;
  user-select: none !important;
  vertical-align: middle !important;
}


/* v166: round table outer corners (employee tab left table) */
#settingsEmployees .employee-col-left{
  border-radius: 12px !important;
  overflow: hidden !important; /* clip inner borders to rounded corners */
}

/* border-collapse: separate is needed for border-radius to render reliably */
#settingsEmployees table.employee-table-fixed{
  border-collapse: separate !important;
  border-spacing: 0 !important;
  border-radius: 12px !important;
}

/* top corners */
#settingsEmployees table.employee-table-fixed thead tr:first-child th:first-child{
  border-top-left-radius: 12px !important;
}
#settingsEmployees table.employee-table-fixed thead tr:first-child th:last-child{
  border-top-right-radius: 12px !important;
}

/* bottom corners */
#settingsEmployees table.employee-table-fixed tbody tr:last-child td:first-child{
  border-bottom-left-radius: 12px !important;
}
#settingsEmployees table.employee-table-fixed tbody tr:last-child td:last-child{
  border-bottom-right-radius: 12px !important;
}

/* avoid background bleeding through rounded corners */
#settingsEmployees table.employee-table-fixed th,
#settingsEmployees table.employee-table-fixed td{
  background-clip: padding-box;
}


/* v167: rounded OUTER border via wrapper, avoid relying on cell borders at corners */
/* frame: table only (not the add button) */
#settingsEmployees .employee-table-frame{
  border: 1px solid var(--grid-border, #d7dde6) !important;
  border-radius: 12px !important;
  overflow: hidden !important;
  background: #fff !important;
}

/* remove the table's own outer border (use wrapper) */
#settingsEmployees .employee-table-frame table.employee-table-fixed{
  border-collapse: separate !important;
  border-spacing: 0 !important;
  width: 100% !important;
}

/* ensure cell borders remain, but drop borders on the outer edge so wrapper border is the outline */
#settingsEmployees .employee-table-frame table.employee-table-fixed thead tr:first-child th{
  border-top: 0 !important;
}
#settingsEmployees .employee-table-frame table.employee-table-fixed tbody tr:last-child td{
  border-bottom: 0 !important;
}
#settingsEmployees .employee-table-frame table.employee-table-fixed tr > :first-child{
  border-left: 0 !important;
}
#settingsEmployees .employee-table-frame table.employee-table-fixed tr > :last-child{
  border-right: 0 !important;
}


/* v168: draw rounded outer border as overlay to avoid "missing corner" from cell borders/sticky layers */
/* frame: table only (not the add button) */
#settingsEmployees .employee-table-frame{
  border: 0 !important;                 /* use overlay instead */
  border-radius: 12px !important;
  overflow: hidden !important;
  position: relative !important;
  background: #fff !important;
}
/* overlay border sits above table/cells so corners look rounded even with sticky headers */
#settingsEmployees .employee-table-frame::after{
  content: "";
  position: absolute;
  inset: 0;
  /* draw border fully INSIDE to avoid overflow clipping at corners */
  border-radius: 12px;
  box-shadow: inset 0 0 0 1px var(--grid-border, #d7dde6);
  pointer-events: none;
  z-index: 10;
}
/* keep table from painting outside */
#settingsEmployees .employee-table-frame table.employee-table-fixed{
  background: transparent !important;
}
/* ensure sticky header doesn't cover the border overlay */
#settingsEmployees .employee-table-frame thead th{
  z-index: 1 !important;
}

</style>`;

  const pages=storeIds.map(storeId=>{
    const store=schedule.masterSnapshot.stores.find(s=>s.id===storeId);
    if(!store) return "";
    const employees=getEmployeesInStore(schedule,storeId);
    const storeCodes=(store.storeCodes||[]).filter(c=>c.type!=="disabled");

    const thead = `
      <thead>
        <tr>
          <th class="namecol" rowspan="2">従業員</th>
          ${Array.from({length:daysInMonth},(_,i)=>`<th>${i+1}</th>`).join("")}
        </tr>
        <tr>
          ${Array.from({length:daysInMonth},(_,i)=>{
            const d=i+1;
            const w=new Date(year,month-1,d).getDay();
            const cls = w===0 ? "sun" : w===6 ? "sat" : "";
            return `<th class="weekday ${cls}">${weekDays[w]}</th>`;
          }).join("")}
        </tr>
      </thead>`;

    const bodyRows=employees.map(emp=>{
      const name=formatEmployeeName(emp.lastName, emp.firstName);
      const mainTds=Array.from({length:daysInMonth},(_,i)=>{
        const d=i+1;
        const v=getAssignmentValue(schedule,storeId,emp.id,"main",d)||"";
        return `<td>${escapeHtml(v)}</td>`;
      }).join("");
      const noteTds=Array.from({length:daysInMonth},(_,i)=>{
        const d=i+1;
        const v=getAssignmentValue(schedule,storeId,emp.id,"note",d)||"";
        return `<td>${escapeHtml(v)}</td>`;
      }).join("");
      return `
        <tr>
          <th class="namecol" rowspan="2">${escapeHtml(name)}</th>
          ${mainTds}
        </tr>
        <tr class="noteRow">
          ${noteTds}
        </tr>`;
    }).join("");

    const supportRows=storeCodes.filter(sc=>sc.type!=="disabled" && (sc.code==="E"||sc.code==="F")).map((sc,idx)=>{
      const code=sc.code;
      const label=code+"謹";
      const tds=Array.from({length:daysInMonth},(_,i)=>{
        const d=i+1;
        const supporter=getSupporterFor(schedule,storeId,code,d)||"";
        return `<td>${escapeHtml(supporter)}</td>`;
      }).join("");
      return `
        <tr class="supportRow ${idx===0 ? "supportFirst" : ""}">
          <th class="namecol supportHead">${escapeHtml(label)}</th>
          ${tds}
        </tr>`;
    }).join("");

    return `
      <div class="page">
        <div class="title">${escapeHtml(store.name)}　${escapeHtml(wk.gengo)}${escapeHtml(wk.yearStr)}年${month}月</div>
        <div class="subtitle">勤務予定表</div>
        <table>${thead}<tbody>${bodyRows}${supportRows}</tbody></table>
        <div class="small">※ 印刷ダイアログで「A4 横」「余白：標準（または最小）」を推奨します。</div>
      </div>`;
  }).join("");

  return `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"/><title>${escapeHtml(year)}-${String(month).padStart(2,"0")} 勤務表</title>${style}
<style id="v186-employee-compact-28-and-delete-radius">
/* v186: 従業員タブも 28px 高さに統一（休暇コードタブと揃える） */
#settingsEmployees table.settings-table.employee-table-fixed input,
#settingsEmployees table.settings-table.employee-table-fixed select{
  height: 28px !important;
}

/* 従業員タブのテーブル内ボタンも 28px に（「削除」「追加」等を含む） */
#settingsEmployees table.settings-table.employee-table-fixed button{
  height: 28px !important;
  min-height: 28px !important;
  padding: 0 10px !important;  /* 上下paddingをゼロにして高さを抑える */
  line-height: 1 !important;
  box-sizing: border-box !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}

/* 従業員タブ：ドラッグハンドルの高さも合わせる */
#settingsEmployees td .emp-drag-handle{
  min-height: 28px !important;
}

/* 従業員タブ：削除ボタンの角丸を休暇コードタブ（radius:10px）に合わせる */
#settingsEmployees .employee-table-frame .btn-delete,
#settingsEmployees .employee-table-frame button[data-action="delete-employee"]{
  border-radius: 10px !important;
  font-size: 12px !important;
}
</style>
</head><body>${pages}</body></html>`;
}

/* ===== IME alert ===== */
function showIMEAlert(){
  dom.imeAlert.classList.add("visible");
  clearTimeout(imeAlertTimer);
  imeAlertTimer=setTimeout(()=>dom.imeAlert.classList.remove("visible"), 2500);
}

/* ===== Utilities ===== */
function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
function lightenColor(hex, amount){
  const num=parseInt(hex.slice(1),16);
  let r=(num>>16)&0xff, g=(num>>8)&0xff, b=num&0xff;
  r=Math.round(r+(255-r)*amount);
  g=Math.round(g+(255-g)*amount);
  b=Math.round(b+(255-b)*amount);
  return "#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
}
function formatEmployeeName(lastName, firstName){
  const s=(lastName||"")+(firstName||"");
  if(s.length<=4) return (lastName||"")+"　"+(firstName||"");
  return (lastName||"")+(firstName||"");
}
function getDaysInMonth(year, month){ return new Date(year, month, 0).getDate(); }
function toWareki(year, month){
  if(year>2019 || (year===2019 && month>=5)){
    const n=year-2019+1;
    return {gengo:"令和", yearStr: n===1 ? "元" : String(n)};
  }
  const n=year-1989+1;
  return {gengo:"平成", yearStr:String(n)};
}
function nextMonthKey(ym){
  const [yStr,mStr]=ym.split("-");
  let y=parseInt(yStr,10), m=parseInt(mStr,10);
  m+=1; if(m>12){ m=1; y+=1; }
  return `${y.toString().padStart(4,"0")}-${m.toString().padStart(2,"0")}`;
}
function getEmployeesInStore(schedule, storeId){
  return schedule.masterSnapshot.employees
    .filter(e=>e.storeId===storeId)
    .sort((a,b)=>(a.orderInStore||9999)-(b.orderInStore||9999));
}
function escapeHtml(str){
  return String(str)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
</script>
</body>
</html>